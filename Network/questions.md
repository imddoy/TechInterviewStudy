# 응용계층 예상질문

<aside>
💡

**✅HTTP 프로토콜에 대해 설명해주세요.**

Hypertext transfer protocol의 약자로,

다른 페이지의 링크를 가지고 있는 문서를 전송하는 프로토콜입니다.

즉, 서버와 클라이언트가 다양한 데이터를 주고받을 수 있도록 하는 전송 규약입니다.

**✅HTTP 프로토콜이 가진 특성을 몇가지 설명해보세요.**

무상태성, 비연결성이라는 특성을 가지고 있습니다.

먼저, 무상태성이란 서버가 클라이언트의 상태를 기억하지 않는 것입니다.

예를 들어, 사용자가 페이지에서 로그인을 한 뒤 새로운 페이지로 이동하면 서버가 상태를 기억하지 않기 때문에 다시 로그인을 해야합니다.

이 때문에, 계속 재요청을 해야한다는 단점을 가지고 있습니다. 하지만, 서버가 사용자의 상태를 기억하지 않기 때문에 스케일 아웃으로 서버를 확장할 때 쉽게 확장이 가능합니다.

두번째로 비연결성이란, 클라이언트와의 네트워크 연결 자체를 끊는것입니다.

클라이언트와 TCP 연결을 통해 응답까지 마치고 나면 연결 자체를 끊습니다.

많은 클라이언트와 연결을 지속하면 리소스가 많이 사용되는데, 이런식으로 연결 자체를 끊으면 남은 리소스로 더 많은 클라이언트와 연결하고 응답을 줄 수 있습니다.

**✅HTTP와 HTTPS의 차이점은 무엇인가요?**

HTTPS란, HTTP에 SSL을 이용한 보안을 추가한 프로토콜입니다.

HTTP는 평문으로 데이터를 전송하기 때문에 보안에 취약하다는 약점을 가지고 있습니다. 

HTTPS는 이러한 점을 보완하여, SSL을 이용하여 데이터를 암호화해서 중간에 데이터를 가로채더라도 정보가 유출되지 않도록 합니다.

- **HTTPS에서 사용하는 SSL/TLS는 어떤 방식으로 동작하나요?**

SSL/TLS는 `공개키 암호화`와 `대칭키 암호화` 이 두 가지 암호화 방식을 혼합해서 사용합니다.
먼저, 초기 연결 단계에서는 `공개키 암호화`를 사용합니다. 이 방식은 안전하게 키를 교환할 수 있지만, 계산 비용이 높아 대량의 데이터를 처리하기에는 적합하지 않습니다.
그래서 실제 데이터 전송 단계에서는 `대칭키 암호화`를 사용합니다. 대칭키 암호화는 공개키 암호화에 비해 훨씬 빠르기 때문이죠.
초기 핸드셰이크 과정에서 `공개키 암호화`를 이용해 안전하게 `대칭키`를 교환합니다. 이렇게 교환된 `대칭키`를 이용해 이후의 모든 통신을 암호화하는 거죠.
이런 방식을 통해 SSL/TLS는 보안성과 효율성을 모두 확보할 수 있습니다. 안전하게 키를 교환하면서도, 실제 데이터 전송은 빠르게 이루어질 수 있는 것이죠.

1. 클라이언트가 서버에 연결을 요청하며 지원 가능한 암호화 방식 목록을 전송합니다.
2. 서버는 암호화 방식을 선택하고, SSL 인증서를 클라이언트에게 전송합니다.
3. 클라이언트는 서버의 인증서를 확인하고, 세션 키 생성에 사용할 랜덤 데이터를 전송합니다.
4. 서버와 클라이언트는 각자 세션 키를 생성합니다.
5. 이후 통신은 이 세션 키를 사용하여 암호화됩니다.

✅**HTTP Method GET 과 POST 메소드를 설명해보세요.**

GET은 데이터를 조회하는 메소드입니다. url에 데이터를 붙여 서버에 요청합니다. 이 때문에 로그나 캐시에 남을 수 있습니다.

POST는 서버로 데이터를 전송하는 메소드입니다. GET과 다르게 body에 데이터를 담아 서버에 보냅니다. body에 데이터를 포함하기 때문에 보안면에서 유리할 수 있습니다.

- **GET과 POST 중 보안이 더 좋은 방식은 무엇인가요?**

POST가 GET보다 보안 측면에서 유리합니다. GET은 URL에 데이터가 포함되기 때문에 로그나 캐시에 남을 수 있지만, POST는 본문에 데이터를 포함하여 전송합니다.

- **GET과 POST는 상태를 어떻게 다르게 처리하나요?**

GET은 주로 멱등성을 가지며, 동일한 요청을 여러 번 보내도 같은 결과를 얻을 수 있습니다. 반면, POST는 멱등성이 없으며, 여러 번 요청하면 그에 따라다른 결과를 얻을 수 있습니다.

**✅PUT 메서드와 PATCH 메서드의 차이점에 대해 설명해주세요.**

PUT은 데이터 필드 전체를 수정하는 메서드 입니다. 전체 필드 값을 담아야하며, 만약 없는 경우 null값으로 저장됩니다.

PATCH는 이와 다르게, 일부의 필드만을 수정하는 메서드입니다. 전체 필드 값이 필요하지 않습니다.

따라서, 수정해야하는 필드 값이 많지 않을 때는 혹시 모를 null 값 발생에 대비하여 PATCH를 이용하는 것이 유리하다고 볼 수 있습니다.

**✅www.naver.com 브라우저에 접속하는 과정을 설명해보세요.**

먼저, 클라이언트가 웹브라우저에 url을 입력합니다.

브라우저는 입력된 도메인 이름을 DNS에 보내 IP 주소를 찾습니다.

IP주소를 찾으면 해당 IP주소에 HTTP 요청 메시지를 보냅니다.

서버는 해당 요청을 처리하여 html, 리소스 등을 브라우저에게 다시 보냅니다.

브라우저는 받은 데이터를 웹페이지로 렌더링 하여 클라이언트에게 보여줍니다.

- **브라우저가 서버에 보낸 요청이 중간에서 가로채지지 않도록 보장하는 방법은 무엇인가요?**

HTTPS를 사용하여 요청과 응답을 SSL/TLS로 암호화하면, 중간자 공격으로부터 데이터를 보호할 수 있습니다.

- **DNS 조회 후 IP 주소를 찾을 수 없을 때 브라우저는 어떻게 처리하나요?**

브라우저는 DNS 조회 실패로 인해 서버에 연결할 수 없으며, 404 Not Found와 같은 에러 페이지를 사용자에게 표시합니다.

**✅REST API를 담당 구현하셨다고 적으셨는데, REST가 무엇인지 설명해보세요.**

자원을 정의하고 자원에 대한 주소를 지정하는 네트워크 아키텍처의 모음입니다. 이때, 자원이란 db에 저장되어있는 데이터 하나하나를 의미합니다.

이 규칙에 따라 설계된 API가 rest api라고 할 수 있습니다.

**✅CORS에 대해 설명해주세요**

브라우저가 다른 도메인에서 요청하는 리소스에 대해 접근을 허용하는 방식이 CORS 입니다. 보안상의 이유로 기본적으로 다른 도메인의 요청은 차단하지만, CORS 헤더를 통해 일부 완화할 수 있습니다.

- **터미널에서 curl과 같은 도구를 사용하거나 postman 같은 도구를 이용해 백엔드 서버에 요청을 보내면 CORS로 막을 수 있나요?**

아니요, postman 같은 도구를 이용하면 CORS로 막을 수 없습니다.

CORS는 오로지 웹 브라우저가 자바스크립트를 통해 리소스에 접근하려고 했을 때만 동작하는 보안 정책입니다. 

postman 같은 경우는 브라우저를 거치지 않고 HTTP 요청을 바로 생성하고 서버로 보내기 때문에, 브라우저가 수행하는 프리플라이트 요청 등을 하지 않게 됩니다.

따라서 CORS로 막을 수 없습니다.

- **CORS 프리플라이트(Preflight) 요청은 무엇인가요?**

프리플라이트의 요청은 브라우저의 요청으로 인해 서버의 데이터가 변경되는 post, delete 와 같은 경우에 사용합니다. 프리플라이트 요청으로 먼저 안전한지 확인 한 후 , 확인이 끝나면 본격적인 요청을 보낼 수 있게 동작합니다.

이를 통해, 서버가 통신을 시작하기 전에 미리 파악하고 제어할 수 있게 해줍니다.

**✅브라우저 저장소에 대해서 설명해주세요.**

브라우저 저장소의 종류는 Cookie, WebStorage 두가지로 나눠지고, WebStorage는 LocalStorage와 SessionStorage로 이루어져 있다.

**1) 쿠키**

- 목적 : 쿠키는 서버와 클라이언트가 지속적으로 데이터 교환을 하기 위해 만들어짐. cookie를 설정하면 이후 모든 요청은 쿠키정보를 포함하여 서버로 전송 -> 서버와의 통신을 목적으로 만들어 졌기 때문에 쿠키에 쓸데없는 값이 많다면 그만큼 네트워크 트래픽이 증가

**2) 웹 스토리지**

- 스토리지는 데이터가 클라이언트단에 저장만 되어있을 뿐 서버로의 전송은 이루어지지 않음
- 용량 제한이 쿠키에 비해 넉넉하고, 만료일자를 따로 정하지 않음

**1) 로컬 스토리지 ( Local Storage ) - 영구 / 브라우저간 공유**

- 브라우저를 종료해도 데이터를 영구적으로 보관
- 도메인만 같으면 모든 브라우저 간에 전역적으로 데이터가 공유되는 특성

**2) 세션 스토리지 ( Session Storage )**  **- 비영구 / 브라우저간 공유x**

- 세션 스토리지에 저장된 데이터는 브라우저 *세션이 유지되는 동안만 존재하기 때문에 브라우저가 종료되면 데이터가 삭제(비영구성).
- 도메인이 같더라도 브라우저가 다르면 각각의 세션 스토리지가 형성되어 데이터 공유가 되지 않음

✅**쿠키와 세션의 차이점은 무엇인가요?**

쿠키는 작은 데이터를 클라이언트 쪽에 저장해놓은 것이고, 서버가 이를 이용하여 클라이언트를 식별합니다.

세션은, 클라이언트가 보내는 명령어들을 일련의 상태로 보고, 그 상태를 유지하려는 것입니다. 세션의 경우 서버가 클라이언트의 정보를 기억하며, 클라이언트가 쿠키에 담아 보낸 세션 아이디를 통해 서버에서 클라이언트를 식별합니다.

결론적으로, 쿠키는 브라우저에 정보가 저장되고, 세션은 서버에 저장된다는 차이점이 있습니다.

- **쿠키와 세션 중 보안이 더 중요한 것은 무엇인가요?**

세션이 서버 측에 저장되기 때문에, 쿠키보다 보안성이 더 높습니다. 그러나 세션이 유출될 경우에도 보안 위험이 발생할 수 있습니다.

- **쿠키가 만료되면 세션은 어떻게 처리되나요?**

쿠키가 만료되면 클라이언트는 더 이상 서버에 세션 ID를 전송할 수 없으므로, 서버 측에서 해당 세션을무효화하게 됩니다.

**✅세션 기반 인증과 토큰 기반 인증의 차이점과 각각 어느 경우에 적합한 지 설명하세요.**

세션 기반 인증은 먼저, 클라이언트가 로그인 하면 서버에서 세션을 만듭니다. 해당 세션의 id를 클라이언트에게 전달해주면 클라이언트는 쿠키에 저장해두었다가 요청할때마다 같이 서버에게 보내는 방식입니다. 세션은 정보를 직접 서버에 저장해두기 때문에, 서버부하가 발생할 수 있습니다.

토큰 기반 인증은 클라이언트가 로그인하면 서버가 jwt같은 토큰을 발급합니다. 해당 토큰은 클라이언트가 저장했다가 요청 시마다 같이 보냅니다. 토큰은 자체적으로 사용자의 정보를 포함하고 있기 때문에 성능 측면에서 훨씬 유리합니다.

- **세션 기반 인증에서 서버 부하가 발생하는 이유는 무엇인가요?**

세션 기반 인증에서는 서버가 각 사용자의 세션 정보를 메모리에 저장하여 인증을 처리하기 때문에, 많은 사용자가 접속할수록 서버 메모리가 소모되며 부하가 발생합니다.

- **토큰 기반 인증의 무상태성은 어떻게 확장성을 지원하나요?**

토큰 기반 인증에서는 서버가 상태를 저장하지 않고, 매 요청마다 토큰을 검증하여 인증을 처리하기 때문에, 여러 서버 간 세션 동기화가 필요하지 않으며 확장성이 뛰어납니다.

**✅API Gateway란?**

API Gateway는 여러 마이크로 서비스로 이루어진 시스템에서 클라이언트 요청을 중앙에서 관리하고 분배하는 역할을 하는 서버입니다. 

API Gateway를 등록하면 클라이언트는 각 서비스의 엔드포인트 대신 api gatewy로 요청을 전달하고, api gateway가 엔드포인트에 요청을 하여 응답을 클라이언트에게 다시 전달해줍니다.

인증,로드 밸런싱,속도 제한, 캐싱 등 다양한 기능을 수행하며, 클라이언트는 API Gateway를 통해 일관된 인터페이스로 여러 서비스를 호출할 수 있습니다.

- **API Gateway의 주요 기능은 무엇인가요?**

API Gateway는 요청 분배, 인증 및 권한 부여, 캐싱, 모니터링, 로깅 등의 기능을 수행하며, 여러 마이크로서비스 간의 통신을 중앙집중화합니다.

- **API Gateway의 성능 저하가 발생할 경우 시스템에 미치는 영향은 무엇인가요?**

API Gateway의 성능이 저하되면 모든 서비스의 응답 시간이 느려지며, 이는 전체 시스템의 병목 현상을 초래할 수 있습니다.

- **API Gateway 장애를 대비하기 위한 핵심 요소는 무엇인가요?**

고가용성을 위해 다중 인스턴스 배포, 로드 밸런싱, 오토스케일링, 페일오버와 같은 방안이 필수적입니다.

- **API Gateway에서 페일오버와 로드 밸런싱은 어떻게 다르게 작동하나요?**

로드 밸런싱은 정상적으로 작동하는 여러 인스턴스 간에 트래픽을 분산시키는 기능이며, 페일오버는 장애가 발생한 경우에만 백업 시스템으로 전환하는 기능입니다.

**✅JWT 토큰이란?**

JWT는 JSON 포맷을 사용하여 정보를안전하게 전송하는 방식입니다. JWT는 세 부분으로 나뉘며, 헤더, 페이로드, 서명으로 구성됩니다. 토큰은 주로HTTP 헤더에 포함되어 전송됩니다. JWT는 서버에 상태를 저장하지 않고 사용자의 인증 상태를 유지할 수 있어, 무상태성을 갖는 토큰 기반 인증 방식입니다.

- **JWT는 왜 무상태성인가요?**

JWT는 인증 상태를 토큰 자체에 포함하기 때문에, 서버에서 별도로 세션을 저장하지 않아도 요청마다 클라이언트가 토큰을 보내어 인증 상태를 유지할 수 있습니다.

- **JWT 토큰이 탈취되었을 경우 어떻게 대처해야 하나요?**

토큰이 탈취되었을 경우 토큰의 만료 시간을 짧게 설정하거나, 토큰 무효화 기능을 사용하여 더 이상 사용할 수 없도록 해야 합니다. HTTPS를 사용하여 전송 중 탈취를 방지할 수 있습니다.

**✅서버 확장의 두 가지 방법에 대해 설명해보세요.**

스케일 업, 스케일 아웃이라는 방법이 있습니다.

먼저, 스케일 업이란 서버 확장 시 서버의 사양을 올리는 방법입니다. 예를 들어, 1이라는 능력을 가진 서버 한 대를 부품을 바꾸거나 CPU등을 추가하여 4 정도의 능력으로 만드는 것입니다.

스케일 아웃이란 서버 확장 시 서버의 개수를 늘리는 방법입니다. 예를 들어, 1이라는 능력을 가진 서버를 4대로 늘려 4정도의 능력을 만듭니다.

**✅로드 밸런싱에 대해 설명해주세요.**

로드 밸런싱은 서버나 장비의 트래픽을 분산시키기는 것을 의미합니다. 로드밸런서가 대표 IP 주소를 가지고 마치 하나의 백엔드 서버인 것 처럼 클라이언트 요청을 받습니다. 로드밸런서는 자신과 연결된 실제 백엔드 서버의 IP주소로 클라이언트 요청을 분산하여 보냅니다.

이러한 방법으로 트래픽을 분산시키는 것입니다.

**✅로드 밸런싱 알고리즘 중 대표적인 라운드 로빈, 최소 연결 방식 에 대해 설명해보세요.**

**4-1. 라운드 로빈(Round Robin)**

(1) 로드 밸런싱에서 가장 많이 사용되는 알고리즘으로 **클라이언트의 요청을 여러 대의 서버에 순차적으로 분배**하는 방식입니다. 추가적인 연산 과정 없이 **들어온 요청을 빠르게 서버로 분산하는 작업에 포커스**를 맞춘 방식입니다.

(2) 모든 서버의 스펙이 동일하거나 비슷한 경우에 사용해 볼 수 있는 밸런싱 알고리즘입니다.

**4-4. 최소 연결(Least connection)**

(1) 요청이 들어온 시점에 가장 적게 연결되어 있는 서버로 요청을 전송하는 방식입니다.

(2) 서버에 분배된 트래픽이 일정하지 않을 경우 사용해 볼 수 있는 알고리즘입니다.

**✅L4와 L7 로드 밸런싱의 차이는 무엇인가요?**

**L7계층 로드밸런서**

: 애플리케이션 계층에서 작동하는 로드밸런서

- 주로 HTTP, HTTPS 를 기반으로 클라이언트-서버 간의 트래픽을 분산
- 단점 : 처리 속도가 느림 → 패킷의 L7 정보를 분석해야하기 때문

→ 웹 서비스, **API 게이트웨이**, CDN 등 L7의 로드 밸런싱이 필요한 서비스

**L4계층 로드밸런서**

: 전송 계층에서 작동하는 로드밸런서

- 주로 TCP, UDP 를 기반으로 클라이언트-서버 간의 트래픽을 분산
- 장점 : 응답 속도가 빠름 → 패킷의 헤더 정보만 이용하기 때문에

→ 온라인 게임, 스트리밍 서비스 등 **실시간 트래픽 처리**가 중요한 서비스

</aside>


# 전송계층 예상질문

<aside>
💡

**✅ 전송계층에 대해서 설명해주세요.**

: 전송계층이란 네트워크 양 끝의 호스트 사이를 연결하는 역할을 한다.

데이터를 패킷단위로 잘라서 포트 번호로 애플리케이션을 구분하여 호스트에게 전달한다.

**✅ 소켓(Socket)이 뭔가요?**

: 응용 계층의 애플리케이션이 전송 계층에게 데이터를 전송하기 위해 소켓을 이용합니다. 소켓은 응용 계층과 전송 계층 사이의 인터페이스 역할을 하며 호스트를 연결하는 역할을 합니다.

**✅ 소켓통신과 Http통신의 차이점은 무엇인가요?**

: 소켓은 양방향 통신이 가능하고, http는 그렇지 않다는 것이 가장 큰 차이점입니다. http는 요청, 응답만 가능하기 때문에 롱폴링 방식등을 이용하여 특정 이벤트가 발생할때마다 클라이언트 서버에게 요청하는 등의 방법으로 통신해야합니다. 하지만, 소켓은 연결이 지속되기 때문에 양방향 통신이 가능합니다.

**✅ 포트 번호는 왜 필요한가요 ? (어플리케이션 구분이라는 본질을 짚는지 확인)** 

: 하나의 IP주소를 가지고 있는 컴퓨터가 있다면 그 컴퓨터 내의 다양한 애플리케이션 중 어떤 애플리케이션인지 구분할 수 없기 때문입니다. 여러 애플리케이션이 동시에 통신하기 위해서는 애플리케이션을 구분해줄 수 있는 포트번호가 필요합니다.

- **포트 번호는 몇 번부터 몇 번까지 존재하나요?**
    
    : 0 ~ 65535번까지 존재합니다. 그 중 0~1023번이 HTTP와 같은 표준 서비스가 이용하는 포트번호 범위입니다. 49152~65535번이 클라이언트가 서버에 접속 시 사용하는 포트번호 범위입니다.
    
- **80번, 443번 포트의 의미는 무엇인가요?**
    
    : 80번 포트는 HTTP 웹 서버의 포트를 의미하고, 443번 포트는 HTTPS 웹 서버의 포트를 의미합니다.
    
- **동적 포트(dynamic port)와 정적 포트(static port)의 차이를 아시나요?**
    
    : 정적 포트는 443번을 쓰는 HTTPS, 80번을 쓰는 HTTP 처럼 특정 서비스가 고정적으로 사용하는 포트 번호를 의미합니다. 반대로 동적 포트는 클라이언트가 서버에 접속할 때  49152~65535 중 자동 생성되는 포트를 의미합니다.
    
    1. **하나의 서버에서 여러 앱이 동시에 통신하는데 포트 충돌은 어떻게 해결하나요?**
    
- **포트 충돌이 발생하면 어떻게 처리하나요?**
    
    : 어떤 프로그램이 같은 포트를 이미 사용 중이면 새로운 서버는 해당 포트로 열리지 않습니다. 다른 프로그램을 종료하여 해당 포트를 사용하거나, 다른 포트로 재배정하는 등의 방법으로 해결할 수 있습니다.
    

---

**TCP/UDP**

**✅ TCP와 UDP의 차이를 설명해보세요.**

: TCP는 3-way handshake로 연결을 맺은 다음 데이터를 보내기 때문에 신뢰성이 높습니다. 가상회선 패킷 교환 방식을 이용해서 모든 패킷이 같은 경로로 전달되기 때문에 패킷 사이 순서를 보장합니다. 하지만 느리다는 단점이 있습니다.

UDP는 연결을 맺지 않고 바로 보내기 때문에 신뢰할 수 없다는 단점이 있습니다. 데이터그램 패킷 교환 방식을 이용해서 패킷이 독립적으로 최적의 경로를 선택하기 때문에 패킷 사이 순서가 보장되지않습니다. 하지만 빠르다는 장점이 있습니다. 

- **그럼 TCP는 어떤 방식으로 신뢰성을 보장하나요?**
    
    : 먼저, 응답 기반 재전송 방식이 있습니다. 클라이언트가 요청을 보낸 후 서버로부터 응답이 오지 않으면 재전송합니다.
    
    두번째로, 순서번호가 있습니다. TCP 세그먼트에는 번호가 붙어서 패킷 순서가 다르게 도착해도 번호를 통해 재정렬할 수 있습니다.
    
    또, 체크섬을 이용한 방법입니다. 데이터가 중간에서 손상되면 체크섬이 불일치하게 되는데, 서버는 해당 패킷을 무시하고 클라이언트가 재전송하게 됩니다.
    
- **TCP의 흐름 제어나 혼잡 제어는 각각 어떻게 작동하나요?**
    
    : 먼저 흐름 제어는 보내는 쪽과 받는 쪽의 데이터 처리 속도를 해결하기 위한 기법입니다. 받는 쪽이 패킷을 받을 수 있는 버퍼의 크기가 한정적인데 보내는 쪽의 전송 속도가 너무 빠르면 버퍼가 가득차서 패킷이 손실되는 상황이 발생합니다. 따라서 어느 정도의 데이터를 전송할지 제어하는 방식이 흐름제어 입니다.
    
    혼잡 제어는 보내는 쪽과 받는 쪽 사이의 네트워크 내에서 패킷 수를 조절하는 기법입니다. 한 라우터에 데이터가 많이 몰려서 모든 데이터를 처리할 수 없는 상황이라고 가정했을때, 보낸 데이터에 응답이 없으면 보내는 쪽은 패킷을 재전송하게 됩니다. 이 때문에 혼잡이 가중됩니다. 따라서 데이터를 어느 정도의 속도로 전송할지 제어하는 방식이 혼잡제어입니다.
    
- **UDP는 왜 실시간 통신에서 자주 쓰이나요?**
    
    : TCP처럼 재전송하는 과정이 없고, 헤더가 작아서 빠르게 전송할 수 있습니다. 또한, 스트리밍 같은 실시간 통신은 하나 놓친다고 전체의 흐름이 끊기는 것이 아니고 빠른 도착이 더 중요하기 때문에 패킷의 순서를 보장하지 않는 udp가 오히려 유리합니다.
    
- **UDP를 썼을 때 데이터 유실이 나면 어떻게 처리하나요?**
    
    : udp 자체는 회복이 불가능하고, 필요한 경우 애플리케이션에서 직접 구현하는 방식으로 처리합니다. 예를 들어, 스트리밍의 경우는 끊겨도 건너뛰고 빠른 도착을 우선시하고, 온라인 게임의 경우 자체 재전송 알고리즘을 구축합니다.
    

**✅ TCP 3,4 way handshake의 단계수 차이가 나는 이유**

: 4-way handshake에서 클라이언트가 보낼 데이터를 다 보냈더라도 서버는 아직 보낼 데이터가 남아있을 수도 있습니다. 따라서 클라이언트와 서버 양쪽이 각각 끝냈다는 것을 알리고, 상대방에게 응답을 줘야하기 때문에 4way가 되는 것입니다. 
**✅ ISN을 0부터 시작하지 않고 난수로 생성하여 설정하는 이유**

( ISN 은 TCP에서 패킷 순서 번호 시작점 )

: 예측 가능한 ISN으로 설정하면 해킹을 시도하는 공격자가 TCP 세션을 위조하는 스푸핑 위험이 있습니다. 또한, 만약 이전 세션에서 패킷이 남은 경우 순서번호가 중복되었다고 오해할 수 있기 때문에 충돌 방지를 위해 난수로 생성합니다.

**✅ TIME WAIT의 존재 이유**

: 4-way handshake에서 서버와 클라이언트가 각각 서로 종료했다고 알리고 응답을 받는 과정에서, 클라이언트가 보낸 마지막 응답을 서버가 못받았을 경우도 있기 때문에 일정 시간동안 wait하며 잠시 기다리는 과정입니다.

또한, 지연패킷이 뒤늦게 도착해서 새 연결에 이 패킷이 영향을 주지 않도록 일정시간 기다리는 과정입니다.

이를 통해 지연된 패킷 등등의 에러가 발생하는 문제를 방지합니다.

**✅ TCP 통신에서 지연 패킷이 발생했을 때 서버는 이것을 어떻게 처리하나요?**

: TCP는 seq 번호를 이용하여 패킷의 순서를 판단하고, 재정렬합니다. 중복된 경우거나, 너무 오래된 패킷은 유효 시간 초과로 패킷을 폐기하는 방식으로 처리합니다.

**✅ 만약 Server에서 FIN 플래그를 전송하기 전에 전송한 패킷이 Routing 지연이나 패킷 유실로 인한 재전송 등으로 인해 FIN 패킷보다 늦게 도착하는 상황이 발생하면 어떻게 될까요?**

: TCP는 이를 무시합니다. 서버에서 finish 패킷을 전송한 이후는 연결이 반 닫힌 상태이기 때문에 더이상 패킷을 받을 수 없습니다. 이러한 경우, 데이터를 받을 수는 없지만 클라이언트가 일정 시간 time wait 상태를 유지하여 지연 패킷이 새 연결에 영향을 미치지 않도록 연결을 끊지않고 기다립니다.

**✅ UDP는 항상 신뢰성을 보장하지 않나요?**

: UDP는 신뢰성이 없는게 아니라 탑재를 안했을 뿐이다. UDP의 진짜 장점은 커스터마이징이 가능하다는 점이다.즉, UDP 자체는 헤더에 들은게 없어 신뢰성이 낮고 제어 기능도 없지만, 이후 개발자가 애플리케이션에서 구현을 어떻게 하냐에 따라서 TCP와 비슷한 수준의 기능을 가질 수도 있다는 말이다.

**✅ TCP의 3-way handshake에 대해 설명해보세요. (연결 수립 과정을 정확히 말하는게 중요)**

: 클라이언트가 서버에게 초기 시퀀스 번호와 함께 연결 요청을 보내면, 서버는 준비 됐다는 응답과 함께 자신의 초기 시퀀스 번호를 보내줍니다. 그러면 클라이언트가 연결을 시작하자는 응답을 보냅니다.

- **SYN 플러딩 공격이 뭔지 아시나요?**
    
    : 해킹을 시도하는 공격자가 요청만 보내고 응답을 보내지 않는 공격입니다. 서버는 연결을 반 열어놓은 상태로 계속 기다리게 되기 때문에 결국 서버의 자원이 고갈되어 정상 연결이 불가해집니다.
    
- **Half-open connection이란 무엇인가요?**
    
    : syn은 왔지만 ack이 오지않아 완전히 열리지 않는 상태의 tcp 연결
    
- **만약 마지막 ACK 패킷이 유실되면 어떤 일이 벌어지나요?**
    
    : 서버가 일정 시간 이후, 준비됐다는 응답과, 초기 시퀀스 번호를 다시 한번 재전송하고, 클라이언트는 응답 패킷을 다시 한번 보내면 문제 없이 연결이 이루어집니다.
    

**✅  슬라이딩 윈도우에 대해 설명해보세요**

: 여러 패킷을 연속적으로 보낼 수 있게 하는 방법입니다. 받는 쪽은 전송하는 쪽에게 자신의 최대 윈도우 사이즈를 알려주고, 보내는 쪽은 해당 사이즈에 맞게 조절하여 패킷을 전송하는 방식입니다.

- **윈도우 크기는 어떻게 조절 되나요 ?**
    
    : 받는 쪽이 자신이 얼만큼 데이터를 받을 수 있는지 계속 알리고, 보내는 쪽은 받는 쪽에서 응답이 빠르게 오면 윈도우 사이즈를 늘리고, 패킷 손실 등의 이슈가 발생하면 윈도우 사이즈를 줄이는 방식으로 조절합니다.
    

**✅  혼잡제어에서 AIMD는 무엇인가요?**

: 합증가, 곱 감소 알고리즘입니다. 보내는 쪽이 하나의 패킷을 전송했을 때, 문제 없이 도착하면 윈도우 사이즈를 하나 증가시킵니다. 이를 반복하다가, 패킷 손실이 발생하거나 타임 아웃이 발생하면 윈도우 사이즈를 절반으로 줄입니다.

**✅ 데이터가 여러개로 나눠져 전송되면 순서를 어떻게 보장하나요 ? (TCP의 순서 보장 메커니즘을 아는지 체크)**

: TCP는 시퀀스 번호로 순서를 보장합니다. tcp 세그먼트에는 시퀀스 번호가 있어, 서버는 도착하는 순서에 상관없이 시퀀스 번호를 기준으로 데이터를 정렬하고, 빠진 경우 재전송을 요청합니다.

- **TCP 세그먼트 구조에 대해 설명해보세요**
    
    : 어떤 애플리케이션과 통신하는지 출발지, 도착지 포트번호, 세그먼트의 시작 바이트 번호, 다음에 어떤 세그먼트를 받고 싶은지 다음 바이트 번호, 연결 상태, 윈도우 사이즈 등을 가지고 있습니다.
    
- **중복 ACK가 들어오면 TCP는 어떻게 반응하나요?**
    
    : 중복 응답이 들어왔다는 것은 특정 구간이 손실되었다는 것을 의미합니다. 3번 연속 중복 응답이 들어온 경우 tcp는 바로 손실된 세그먼트를 재전송하고 네트워크가 혼잡하다고 판단하여 윈도우 사이즈 줄입니다.
    
- **순서가 뒤바뀐 세그먼트가 도착하면 어떻게 처리하나요?**
    
    : 차례대로 오지 않은 세그먼트는 먼저 버퍼에 저장하고, 중복 응답을 보내서 손실된 세그먼트를 재전송 받습니다. 누락된 버퍼가 다시 전송되면 순서를 정렬하여 정상적으로 돌려놓습니다.
    
</aside>

# 네트워크 계층 예상질문

<aside>
💡

**✅ 네트워크 계층의 주요 역할은 무엇인가요? 이를 위해 사용하는 프로토콜은 어떤 것이 있나요?**

: 서로 다른 네트워크 간에 패킷을 전송하는 계층입니다. 목적지까지 가장 안전하고 빠르게 데이터를 보낼 수 있도록 최적의 경로를 설정하는 라우팅 기능을 맡은 계층입니다.

대표적인 프로토콜으로는 IP, ICMP, ARP 등이 있습니다.

**✅ IP 주소에는 IPv4와 IPv6가 있습니다. 이 두 가지의 차이점은 무엇인가요?**

: 가장 큰 차이점은 주소의 길이입니다. IPv4는 32비트 주소를 사용하지만 이에 비해 IPv6는 128비트를 사용하기 때문에 거의 무한에 가까운 주소 공간을 제공합니다.

**✅ IP는 무엇인가요?**

: 네트워크 계층에서 통신하는 주요 프로토콜로, 패킷의 전달을 책임집니다. 이때, 데이터를 패킷으로 보내는 역할에만 충실하고 패킷을 받을 서버가 없거나, 패킷이 분실, 손상되는 경우는 고려하지 않기 때문에 신뢰성 없는 비연결형 전송을 제공한다는 특징이 있습니다.

**✅ IP 주소와 포트는 어떠한 관계가 있나요?**

: IP 주소가 한 컴퓨터의 네트워크 상 주소라고 한다면, 포트는 그 컴퓨터 내의 여러 서버들의 주소를 의미합니다.

**✅ 만약 포트가 열려 있지 않으면 어떻게 되나요?**

: 포트가 열려있지 않다면, 서비스에 연결할 수 없고 통신 불가 상태가 됩니다.

**✅ 공인 IP와 사설 IP의 차이에 대해 설명하세요.**

: 공인 IP란 SK, KT, LG 등 인터넷 서비스 제공자가 제공하는 IP주소를 의미합니다. 이는 전세계에서 유일하고 누구나 접근 가능합니다.

사설 IP란 라우터가 DHCP를 이용하여 내부 기기에게 배정한 것입니다. 같은 네트워크 내부에서 사용하는 내부 IP주소입니다.

**✅ NAT(Network Address Translation)에서 IP와 포트는 어떻게 사용되나요?**

: NAT는 여러 사설 IP들을 하나의 공인 IP로 묶고 포트 번호를 이용해 구분하는 기술입니다. 따라서 전세계 기준으로 사설 IP는 중복되지만 유일한 공인 IP로 묶음으로써 공인 IP 하나로 여러 기기가 인터넷을 사용할 수 있게되는 것입니다.

**✅ 유니캐스트, 브로드캐스트, 멀티캐스트, 애니캐스트에 대해 설명하세요.**

: 일대일 통신, 일대모두 통신, 일대그룹 통신, 1대 가장가까운 노트 통신

**✅ 서브넷 마스크는 무엇이며, 네트워크를 분할하는 데 어떻게 사용되나요?**

: IP주소에서 앞 24비트는 네트워크 부분, 뒤 8비트는 호스트 부분 등등으로 구분하는 기준입니다. 네트워크를 여러개로 분리시켜 브로드캐스트 등을 진행할때 범위가 줄어들어 성능 향상에 도움이 된다는 특징이 있습니다.

**✅ 라우팅 프로토콜이란 무엇이며, 대표적인 라우팅 프로토콜은 어떤 것들이 있나요?**

: 패킷이 목적지까지 효율적으로 전달될 수 있도록 최적의 경로를 설정하는 방법을 정의하는 프로토콜입니다. 

수동으로 경로를 설정하는 정적 라우팅과, 상황에 맞게 경로를 변경하는 동적 라우팅이 있고, 동적 라우팅에는 대표적으로 rip 등의 내부 라우팅과 bgp같은 외부 라우팅이 있습니다.

**✅ 라우팅 알고리즘에 대해 설명하세요.**

: rip 는 라우터가 이웃 라우터에게 내가 아는 거리를 전달하여 최소 거리로 계산하는 방법입니다.

ospf는 모든 라우터가 네트워크 전체 지도를 가지고 있고, 다익스트라 알고리즘으로 최단 경로를 계산하는 방법입니다.

**✅ 라우터와 스위치의 차이에 대해 설명하세요.**

: 라우터는 서로 다른 네트워크 간 데이터 통신을 담당하지만, 스위치는 한 네트워크 내부의 데이터 전송을 담당한다는 점에서 차이가 있습니다.

또한, 스위치는 맥 주소 기반으로 데이터 링크 계층에서 사용되며, 라우터는 IP주소 기반으로 네트워크 계층에서 사용됩니다.

</aside>
