Q : TCP 연결 과정에서, 3 way hanshaking이 있는데, 그 과정에 대해서 설명해주세요!

A : 클라이언트가 서버에게 연결을 하고 싶다고 요청 + 자신의 sequence 번호를 넘겨줌. 서버의 sequence 번호를 전송해줌 → 클라이언트에서 확인을 하고 다시 재 전송해준다.

---

Q : 클라이언트의 상태가 어떻게 변경됨?

A : 클라이언트가 처음에 요청을 보내면 → waiting 상태가 된다. 서버가 다시 응답과 요청을 함꼐 보내면 → 클라이언트의 응답을 기다리는 상태

---

Q : TCP의 연결 수립 과정과 종료 상태는 단계가 하나가 차이가 나는데, 이거를 받았을 떄, 이거를 전송하기 전에 패킷이 유실이 된다면 어떻게 처리?

A : 패킷이 유실이 되는 경우에는, time-wait 상태가 된다. = 클라이언트가 서버의 연결이 끝났다는 응답을 받은 후에 지연된 패킷이 도착했다라는 응답이 받을 수 있다 ⇒ 데이터를 온전히 받을 수는 없지만, 이 지연된 패킷이 새로운 패킷에 영향을 안 가도록 하기 위해서 허용 x

---
Q : 지연된 패킷을 받는 시간을 기다리는 시간은 어떤 시간을 기준으로?

A : 몰라~

---

Q : TCP header에는 sequence # header가 있는데, 이 # header field가 필요한 이유

A : 패킷을 나누어서 보내더라도, 그 패킷의 순서를 보장하기 위해서 → 시퀀스 헤더 넘버대로, 서버에서 패킷을 다시 재정렬할 수 있기 때문에 필요하다.

---

Q : sequence #dml isn을 설정할 떄, 난수를 설정해서 표현하는 이유는?

A : 
1. 보안 문제 → 0부터 시작하는 번호를 쓰게 되면은, 공격자 입장에서 쉽게 유추가 가능.
2. 지연된 패킷이 발생했을 경우에는, 시작 번호가 동일해버리기 쉬워지기 때문에, 서버 입장에서 중복된 패킷을 받았다고 처리할 수가 있다.
---

Q : TCP가 흐름 제어를 하기 위해 stop & wait을 사용하는데, 이때의 문제점은?

A : 몰라~

---

Q : TCP는 혼잡 제어를 하기 위해서, AIMD라는 방식을 사용하는데, 설명!

A : 윈도우라는 서버나 클라이언트 측이 데이터를 받을 수 있는 버퍼의 크기가 있는데, 이 AIMD의 경우, 보내는 쪽이 받는 쪽에게 데이터를 1만큼 보낸다고 가정을 했을때, 받는쪽에서 데이터가 정상적으로 응답했다고 판단하면, 데이터의 크기를 1씩 늘리다가, 패킷이 손실되는 상황이 발생한다면, 보내는 양을 반으로 줄여 나가는 방식이다. 

---
Q : UDP에서는 오류 검사가 어떻게 이루어지냐?

A : UDP의 경우, 따로 오류 검사는 이루어 지고 있지 않지만, 필요하다면 응용 계층에서 패킷을 재전송할 수 있게 알고리즘을 재구성할 수 있다.

---

Q : 가상회선 패킷 교환 방식 vs 데이터링크 교환방식

A : 가상회선 : 경로를 지정한 뒤에 패킷을 보내기 때문에 같은 경로로 이동

데이터 그램 : 즉흥적으로 패킷이 가장 빠른 경로를 찾아서 간다. 

---

Q : CIDR이 무엇인지 알고 있냐?

A : 몰라~

---

Q : Routing protocol 중 distance vector vs link state 방식

A : link state : router가 네트워크 전체이 경로를 알고 있어서, 다익스트라 알고리즘으로 최적의 경로를 찾아 나간다. 

---

Q : ARP가 뭐냐?

A : IP주소를 웹주소로 변환하는 프로토콜. 목적지의 MAC 주소를 알아내는데 사용되고 있다. 

ARP 가 broadcast로 보내지는데, 그 이유는?

몰라~

---

## Feedback

### from 채현
대답을 전체적으로 잘해주셨던 것 같습니다! 구체적으로 모르는 부분도 이해한 내용으로 
답변 흐름이 자연스럽게 이어지도록 대답해주신 부분도 좋았습니다.

### from 나연
설명을 조금 두괄식으로 알기 쉽게 해줘서 좋았습니다. 하지만 말투가 조금 피곤해 보이는 느낌이 없지 않아 있어서 
조금 더 활기차게 해줬으면 좋겠습니다! 설명도 비유를 들어서 짧게 하면 좋겠습니다!
