## OSI 7계층 / TCP-IP 4계층에서 전송 계층의 역할

### 전송 계층

- 양 끝단의 사용자들이 신뢰성있는 데이터를 주고받을 수 있도록 해주어, 상위 계층들이 데이터 전달의 유효성이나 효율성을 생각하지 않도록 해줌
- 시퀀스 넘버 기반의 오류 제어 방식을 사용
- 특정 연결의 유효성을 제어하고 일부 프로토콜은 상태 개념이 있고, 연결기반
  - 전송계층이 패킷들의 전송이 유효한지 확인하고 전송 실패한 패킷들을 다시 전송하는 것을 의미
- 데이터 전송 단위: Segment
- UDP와 TCP는 각각 별도의 포트 주소 공간을 관리하므로 같은 포트 번호를 사용해도 무방함
  - 두 프로토콜에서 동일한 포트 번호를 할당해도 서로 다른 포트로 간주
  - 같은 모듈(UDP or TCP) 내에서도 클라이언트 프로그램에서 동시에 여러 커넥션을 확립한 경우에는 서로 다른 포트 번호를 동적으로 할당

### TCP와 UDP는 왜 나오게 됐는가

- 포트
  - 한 컴퓨터 안에서 어떤 프로세스와 통신할지 식별하는 번호
  - IP가 어떤 컴퓨터인가, 포트가 그 컴퓨터 안의 어떤 프로그램인가
- 포트번호가 나온 이유
  - IP의 역할은 Host to Host만을 지원
  - 하나의 장비안에서 수많은 프로그램들이 통신할 경우 IP만으로는 한계
- TCP와 UDP가 나오게 된 이유
  - IP에서 오류가 발생하면 ICMP에서 알려줌
    but ICMP는 알려주기만 할뿐 대처 못함
    → IP보다 위에서 처리해줘야 함
  - TCP: 데이터의 분실, 중복, 순서가 뒤바뀜 등을 자동으로 보정해줘서 송수신 데이터의 정확한 전달을 할 수 있도록
  - UDP : IP가 제공하는 정도의 수준만을 제공하는 간단한 IP 상위 계층의 프로토콜

## TCP vs UDP

|                | TCP                                                         | UDP                              |
| -------------- | ----------------------------------------------------------- | -------------------------------- |
| 연결 방식      | 연결지향 (3-way handshake)                                  | 비연결 지향                      |
| 신뢰성         | 높은 신뢰성 (패킷 손실 시 재전송)                           | 신뢰성 없음(손실 시 재전송 X)    |
| 속도           | 상대적으로 느림 <br />(연결을 위한 초기 설저어 시간이 걸림) | 빠름                             |
| 패킷 순서 보장 | O                                                           | X                                |
| 헤더 크기      | 20-60 바이트 (상대적으로 큼)                                | 8 바이트 (작음)                  |
| 사용 사례      | 웹(HTTP, HTTPS), 이메일(SMTP), 파일 전송(FTP)               | 스트리밍 (VoIP, 영상), DNS, 게임 |

- TCP는 신뢰성이 중요한 웹 페이지 로딩에 적합
  - 데이터 손실 X
- UDP는 빠른 응답이 중요한 영상 스트리밍에 적합
  - 속도우선
- DNS에서 UDP를 사용하는 이유 : 속도와 효율성

  1. 연결 오버헤드 최소화 (빠른 응답)

     - 비연결 지향의 이점: DNS 쿼리(요청)는 일반적으로 매우 작고 단일 요청과 단일 응답으로 구성

     - TCP 비효율성: TCP는 통신을 위해 3-way Handshake로 연결을 설정하고, 통신 후 4-way Handshake로 연결을 해제하는 과정이 필수적. 이 과정에서 발생하는 프로토콜 오버헤드는 DNS처럼 간단하고 짧은 트랜잭션에는 매우 비효율적

     - UDP 선택 이유: UDP는 연결 설정 과정 없이 데이터를 즉시 전송하는 비연결 지향 방식이므로, DNS 쿼리 처리 시간을 극도로 단축하여 빠른 이름 해석(Name Resolution)을 가능

  2. 데이터 크기와 재시도

     - 작은 데이터 크기: 대부분의 DNS 요청(쿼리)과 응답은 UDP 데이터그램 하나에 충분히 담길 정도로 크기가 작습니다. (전통적으로 UDP 데이터그램 크기의 제한은 512 바이트)
     - 응용 계층에서의 신뢰성 확보: UDP 자체는 비신뢰성(Unreliable) 프로토콜이지만, DNS는 데이터 손실이 발생하면 응용 계층 (DNS 클라이언트)에서 단순히 쿼리를 재전송하여 신뢰성 확보 가능. 복잡한 재전송 로직을 전송 계층(TCP)에 의존할 필요가 없음

  - DNS는 일반적으로 UDP(Port 53)를 사용하지만, 데이터의 양이 많아지거나 특정 상황에서는 TCP를 사용.
    - 데이터 크기 초과: DNS 응답 데이터의 크기가 512 바이트를 초과하는 경우 (특히 DNSSEC 사용 시 또는 많은 양의 레코드를 전송할 때) TCP를 사용하도록 전환
    - 영역 전송 (Zone Transfer): DNS 서버 간에 전체 도메인 영역 데이터베이스를 복사하는 영역 전송 시에는 대용량 데이터를 안정적으로 전송하기 위해 반드시 TCP 사용

### TCP - 전송 제어 프로토콜

- TCP(Transmission Control Protocol) : 패킷 전송을 제어하여 신뢰성을 보증하는 프로토콜
- 안전포장
  단순히 목적지 뿐만 아니라 순서, 검증, 전송 제어 정보가 들어있음
  ![image.png](attachment:c32bc7cf-682f-4ce9-a313-0988d3f77e22:image.png)
- TCP와 IP를 함께 사용하는데, IP가 데이터의 배달을 처리한다면 TCP는 패킷을 추적 및 관리
- 흐름제어 및 혼잡제어 제공
- 꼼꼼한 통신 확인

  - 통신을 시작할 때와 종료할 때 서로 준비가 되어있는지를 반드시 미리 먼저 물어보고 패킷을 전송할 순서를 정하고 나서야 본격적인 통신을 시작
  - 3way : 통신을 시작할때
  - 4way: 통신을 마칠때
    ⇒ 단계가 차이나는 이유: 클라이언트가 데이터 전송을 마쳤다고 하더라도 서버는 아직 보낼 데이터가 남아있을 수 있기 때문에 일단 FIN에 대한 ACK만 보내고, 데이터를 모두 전송한 후에 자신도 FIN 메시지를 보내기 때문
  - 한 번 통신하는데 HandShake를 2번해서 신뢰성을 과하게 보장

    | Flag | 설명                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
    | ---- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | SYN  | 접속 요청을 할 때 보내는 패킷; TCP 접속 시에 가장 먼저 보내는 패킷 <br />Sequence Number를 랜덤으로 설정하여 세션 연결에 사용<br />초기에 Sequence Number를 전송<br /><br />난수를 생성하는 이유: <br />Connection을 맺을 때 사용하는 포트 번호는 유한한 범위 내에서 사용되고 시간이 지남에 따라 재사용됨<br /> → 두 통신 호스트가 과거에 사용된 포트 번호 쌍을 사용하는 가능성이 존재<br />서버 측에서는 패킷의 SYN을 보고 패킷을 구분하게 되는데, 순차적인 Number가 전송되면 이전 Connection으로부터 오는 패킷으로 인식할 수 있음 → 난수로 ISN을 설정함 |
    | ACK  | 상대방으로부터 패킷을 받은 뒤 잘 받았음을 알려주는 패킷<br />다른 플래그와 함께 출력되기도 함<br /><br />Acknowledgement Number 필드가 유효함을 나타냄<br />양 끝단 프로세스가 지속적으로 데이터를 전송한다고 가정하면, 최초 연결 설정 과정에서 전송되는 첫 번째 세그먼트를 제외한 모든 세그먼트의 ACK 비트는 1로 설정된다고 볼 수 있음                                                                                                                                                                                                                   |
    | PSH  | 데이터를 즉시 목적지로 보내라는 의미                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
    | FIN  | 접속 종료를 위한 플래그<br />이 패킷을 보내는 측이 현재 연결을 종료하고자 할 때 사용                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
    | URG  | 긴급 위치(Urgent Pointer) 필드가 유효함을 나타내는 플래그                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
    | RST  | 연결 리셋 응답 또는 유효하지 않은 세그먼트에 대한 응답; 비정상적인 상태를 강제로 종료할 때 사용                                                                                                                                                                                                                                                                                                                                                                                                                                                           |

### UDP - 사용자 데이터그램 프로토콜

- 데이터도 단순 텍스트를 넘어서 동영상이나 음악과 같은 멀티미디어도 전송하면서 데이터의 크기가 점점 커져가며 동시에 빠른 통신이 필요해짐
- TCP 회선을 길게 유지하고 데이터도 스트림이라는 특수한 형태로 보내는 식으로 극복했지만, TCP가 갖는 근본적 특징 때문에 속도 한계 존재함
- 데이터그램 방식을 사용하는 프로토콜로 패킷 간의 순서가 존재하지 않는 독립적인 패킷을 사용함
- 데이터그램 방식
  - 패킷의 목적지만 정해져있다면 중간 경로는 어딜 타든 신경쓰지 않기 때문에 핸드쉐이크 과정 같은 연결 설정 필요 없음
  - TCP의 과정을 거치지 않기 때문에 빠름
    ![image.png](attachment:b1e6b234-e351-41fc-9699-e09a417e1737:image.png)

### TCP 헤더와 UDP 헤더 크기 차이

- TCP
  ![image.png](attachment:a2c4e145-2922-4d25-a89a-688fefdeea77:image.png)
  - 오래전에 설계되었고, 기능이 워낙 많아 헤더가 거의 풀방
  - Source Port: 데이터를 생성한 애플리케이션에서 사용하는 포트번호
  - Destination Port: 목적지 애플리케이션이 사용하는 포트 번호
  - Sequence Number 필드: 세그먼트 순서를 맞추기 위한 필드
  - Acknowledgement Number 필드: 다음 세그먼트 수신 준비 및 모든 데이터 수신 확인 역할
  - Data Offset 필드: TCP 헤더의 크기
  - Reserved 필드: 차후의 사용을 위한 예약된 필드
  - Controls Flags (SYN, ACK, FIN…등): 긴급, 혼잡, 확인, 수신 거부 등의 기능
  - Window size 필드: 수신자가 한번에 받을 수 있는 데이터의 양. 송신자는 Window size만큼 ACK를 기다리지 않고 데이터를 전송. ACK가 계속 왔다갔다 하지 않아도 됨
  - Checksum: 세그먼트 내용의 유효성과 손상 여부 검사
- UDP
  ![image.png](attachment:a6281b11-f005-493e-aa89-c2acfdcebe74:image.png)
  - Source Port: 데이터를 생성한 애플리케이션에서 사용하는 포트 번호
  - Destination Port: 목적지 애플리케이션이 사용하는 포트 번호
  - checksum: 중복 검사의 한 형태로, 오류 정정을 통해 공간(전자 통신)이나 시간(기억 장치)속에서 송신된 자료의 무결성을 보호하는 단순한 방법 (TCP의 체크섬과는 다르게 UDP의 체크섬은 사용해도 되고 안해도 되는 옵션)

### TCP를 버리고 UDP를 선택한 HTTP3.0

1. TCP는 구조상 한계로 개선해도 여전히 느림
   - 네트워크 환경을 바꾸어가면서 소통할 수 있을거라고 생각하지 못했던 TCP
   - 패킷 파싱 속도가 느리거나 중간에 유실되면 병목 생김 (HOLB)
2. UDP는 신뢰성이 없는게 아니라 탑재를 안했을뿐
   - UDP는 커스터마이징이 가능함
   - 헤더에 들은게 없어 신뢰성이 낮고 제어 기능도 없지만 개발자가 구현을 어떻게 하냐에 따라 TCP와 비슷한 수준의 기능을 가질 수 있음
3. UDP를 개조한 QUIC 프로토콜
   - QUIC (Quick UDP Internet Connections)
   - TCP + TLS + HTTP의 기능을 모두 구현하는 프로토콜
   - 1 RTT(Round Trip Time) 소요
     - 클라가 보낸 요청을 서버가 처리한 후 다시 응답해주는 사이클
     - TCP는 1 RTT 필요 + TLS를 사용한 암호화와 핸드쉐이크 = 총 3RTT
     - 한번 연결 성공하면 설정을 캐싱하고 다음 연결때는 바로 연결 → 0 RTT도 가능
4. 패킷 손실 감지에 걸리는 시간 단축
5. 클라이언트의 IP가 바뀌어도 연결이 유지되어 모바일에서 와이파이를 바꾸어도 끊김이 없어짐

## TCP 연결제어

- 3-way handshake
  ![image.png](attachment:a7591f19-c5c5-4eb4-ad35-43b76034fd65:image.png)
  1. 클라이언트는 접속을 요청하는 SYN 패킷을 보냄
     클라이언트는 응답을 기다리기 위해 SYN_SENT 상태로 변함
  2. LISTEN 상태였던 서버는 SYN 요청을 받으면, 클라이언트에게 요청을 수락하는 ACK 패킷과 SYN 패킷을 보냄 (서버도 클라이언트에 접속해야 양방향 통신이 되기 때문)
     SYN_RCVD(SYN_RECEIVED) 상태로 변하여 클라이언트가 ACK 패킷을 보낼 때까지 기다림
  3. 클라이언트는 다시 서버에 ACK 패킷을 보내고, 이후 ESTABLISHED 상태가 되어 통신이 가능하게 됨
- 데이터 통신 과정
  ![image.png](attachment:748b902d-2b8f-42eb-a731-cfe982524ada:image.png)
  1. Established 된 상태에서 서버에게 데이터를 보냄
  2. 서버는 잘 전송받았다고 ACK 플래그를 넣어 응답
  3. 만약 클라이언트가 서버로부터 ACK를 못받았으면 제대로 송신하지 못한걸로 판단하고 데이터를 재전송
- 4-way handshake
  ![image.png](attachment:20d15ad3-4019-47f6-bc19-5db31924533e:image.png)

  1. 서버와 클랄이언트가 TCP 연결이 되어있는 상태에서 클라이언트가 접속을 끊기 위해 CLOSE() 함수를 호출
     → FIN 플래그 보내고 클라이언트는 FIN_WAIT1 상태로 변함
  2. 서버는 클라이언트가 CLOSE()한다는 것을 알게되고 CLOSE_WAIT 상태로 바꾼 후 ACK 플래그를 전송

     만일 서버에서 클라이언트로 보낼 남은 데이터가 있을 경우 이때 나머지 모두 전송

  3. ACK를 받은 클라이언트는 FIN_WAIT2로 변환되고, 이때 서버는 CLOSE() 함수를 호출하고 FIN 플래그를 클라이언트에게 보냄
  4. 서버도 연결을 닫았다는 신호를 클라이언트가 수신하면 ACK 플래그를 보낸 후 TIME_WAIT 상태로 전환 → 모든 것이 끝나면 CLOSED 상태로 변환
     - TIME_WAIT
       서버에서 FINI 플래그를 전송하기 전에 전송한 패킷이 Routing 지연이나 패킷 유실로 인한 재전송 등으로 인해 FIN 패킷보다 늦게 도착하는 경우를 대비하여 클라이언트는 서버로부터 FIN 플래그를 수신하더라도 일정시간(Default: 240s)동안 세션을 남겨놓고 잉여 패킷을 기다리는 과정을 거침

- 포트 상태 정보
  | CLOSED | 포트가 닫힌 상태 |
  | ----------- | -------------------------------------------- |
  | LISTEN | 포트가 열린 상태로 연결 요청 대기중 |
  | SYN_RCV | SYNC 요청을 받고 상대방의 응답을 기다리는 중 |
  | ESTABLISHED | 포트 연결 상태 |

### 흐름 제어(Flow Control)

- 수신자가 처리할 수 있는 데이터 속도가 다르기 때문에, 송신측은 수신측의 데이터 처리 속도를 파악하고 얼마나 빠르게 어느 정도의 데이터를 전송할지 제어
- 데이터를 송신하는 곳과 수신하는 곳의 데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지하는 것
- 송신하는 곳에서 감당이 안되게 많은 데이터를 빠르게 보내 수신하는 곳에서 문제가 일어나는 것을 방지
- 슬라이딩 윈도우 방식을 사용
  - 윈도우라는 데이터를 담는 공간을 동적으로 조절하여 데이터량을 조절
    ![image.png](attachment:5f618aee-190b-49dd-933a-ba3115a4cbd4:image.png)

### 오류 제어(Error Control)

- 통신 도중에 데이터가 유실되거나 잘못된 데이터가 수신되었을 경우 대처
- Go Bank N 기법과 Selective Repeat(선택적인 재전송) 기법을 사용
  - Go Back N 기법: 어느 데이터로부터 오류가 발생했는지 파악하여, 그 부분만 다시 순서대로 보내 제어
    ![image.png](attachment:5b9703c5-3c46-4fdf-9dd8-83e458346b15:image.png)
  - Selective Repeat 기법: 에러난 데이터만 재전송하고 그전에 받았던 순서가 잘못된 데이터 버퍼를 재정렬하여 제어
    ![image.png](attachment:5b87987e-7a78-46c2-be62-3fce0a137be6:image.png)

### 혼잡 제어 (Congestion Control)

![image.png](attachment:4440bdca-5b30-476e-bc6c-b32a29865c4e:image.png)

- 네트워크가 불안정하여 데이터가 원활히 통신이 안되면 제어를 통해 재전송을 하게되는데, 재전송 작업이 반복되면 네트워크가 붕괴될 수 있음
  → 네트워크 혼잡 상태가 감지되면 송신 측의 전송 데이터 크기를 조절하여 전송량 조절
- 네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지하는 것
- 정보의 소통량이 과다하면 패킷을 조금만 전송하여 혼잡 붕괴 현상이 일어나는 것을 방지
- Tahoe, Reno, New Rano, Cubic, Elastic-TCP 등 다양한 기법이 존재함

## 신뢰성/성능 관련

- cwnd: 혼잡 윈도
- ssthresh: 임계값

### AIMD(Additive Increase / Multiplicative Decrease)

- Additive Increase: 혼잡 없으면 cwnd를 조금씩 **선형** 증가 (보통 RTT마다 1 MSS씩)
- Multiplicative Decrease: 혼잡(손실) 감지되면 cwnd를 **절반으로** 급감

⇒ 조심조심 올리다가 혼잡 나면 반으로 확 줄임

### Slow Start

- 문제) AIMD는 처음에 너무 느리게 커짐
- 해결) 처음엔 cwnd를 1, 2, 4, 8 …처럼 RTT마다 2배씩 **지수 증가**
- ssthresh까지는 Slow Start, 그 이후는 AIMD로 전환하는 식(Tahoe / Reno)

### Fast Retransmit

- 동일한 ACK 번호를 3번 연속 받으면 그 패킷 하나가 유실됐다고 판단하고 타임아웃을 기다리지 않고 바로 재전송

### Fast Recovery

- 혼잡 시 cwnd를 1로 확 떨어뜨리지 않고 절반 정도로 줄인 뒤 선형 증가
- 전체 전송률이 너무 바닥까지 안떨어지도록 함

<br />

> TCP 혼잡 제어는 처음엔 Slow Start로 cwnd를 지수적으로 빨리 키우고, ssthresh 이후엔 AIMD로 선형 증가/반 감쇠를 하며, 손실은 타임아웃이나 3 dup ACK로 감지해서 Fast Retransmit/Recovery로 회복

## ETC

### 세그먼트 vs 데이터그램

- 세그먼트
  - TCP에서 사용하는 데이터 단위
  - TCP 헤더 + 데이터(payload)로 구성
- 데이터그램
  - UDP 또는 IP에서 사용하는 데이터 단위
  - (UDP 헤더 + 데이터) 또는 (IP 헤더 + 데이터)

### MSS (Maximum Segment Size)

- TCP가 한번에 보낼 수 있는 데이터 부분의 최대 크기 (byte 단위)
- TCP 헤더와 IP 헤더와 별도
- payload에만 해당
- 계산
  - MSS = MTU - (IP헤더 + TCP헤더)
  - ex) 이더넷 MTU(1500) - IP(20) - TCP(20) = MSS 1460 bytes.
- TCP 연결 시 각 단말이 자신이 감당 가능한 MSS를 SYN 패킷에 담아 보냄
- 두 쪽 중 더 작은 값을 실제 전송 MSS로 채택
- 세그먼테이션을 실제로 어떻게 할지 결정하는 기준

### 소켓

- 네트워크 통신의 끝점
- 소켓 = IP + 포트 + 프로토콜(TCP/UDP)
- TCP 연결 하나는 **`<src IP, src Port, dest IP, dest Port>`로 유일하게 식별됨**

### 프로세스-프로세스 통신

- 전송 계층의 핵심 역할: **“호스트-호스트” 통신(IP)을, “프로세스-프로세스” 통신으로 끌어올리는 것**
- IP: 목적지 컴퓨터까지
- Port+Socket: 목적지 안의 특정 프로세스까지 도달하게 해줌

⇒ 전송계층은 포트번호와 소켓을 이용해서, IP 기반의 호스트-호스트 통신을 실제 애플리케이션 간의 프로세스-프로세스 통신으로 매핑
