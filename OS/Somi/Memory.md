# 메모리

### 프로그램의 실행이란 ?

- 파일 시스템에 존재하던 실행파일이 **메모리에 적재**
- 프로그램이 **CPU를 할당받고 명령을 수행하고 있는 상태**

👉🏻 프로그램이 실행되기 위해선 먼저 프로그램이 메모리에 로드되어야함

👉🏻 OS가 메모리 ( RAM )에 공간을 할당해줌 ( = 유저영역 )

# 1. 메모리

### 메모리 구조 : 유저 영역, 커널 영역

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FIHpR6%2FbtqAI22YET2%2FAAAAAAAAAAAAAAAAAAAAAF3jGUm_unGwqpcGQ6xEj7MtMd06eGmqPRStk_ywy_3A%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1767193199%26allow_ip%3D%26allow_referer%3D%26signature%3DAKMGRmqB7zW93iBSn%252FrhZ5KnaQw%253D">

- 커널 영역 : OS 핵심 코드 실행
    - 시스템의 모든 것을 통제하기 때문에 사용자가 직접 접근 불가
    - 접근 시 system call을 통한 커널모드로 전환이 필요
- 유저 영역 : 일반 애플리케이션 실행
    - 하나의 프로세스를 묶어놓은 세그먼트가 존재
        - 이 세그먼트가 여러 영역으로 나뉘어져있는 것!
        
        ‼️ 즉, 프로세스마다 스택, 힙, 데이터, 코드 영역이 존재한다는 것
        

---

**⁉️ 왜 유저 영역, 커널 영역으로 나뉘어 있을까?**

✅ 

시스템 운영에 필요한 메모리, 운영체제 등이 커널 영역에 올라가 있음

→ 사용자가 커널 영역에 마음대로 접근한다면 ? 시스템이 안정적으로 운용 불가능

EX) 유저가 커널 메모리 직접 수정 → 커널 코드 손상, 시스템 전체 다운

EX) 유저가 다른 프로그램 메모리 훔쳐보기 → 프로세스 간 격리 붕괴

따라서, 사용자가 함부로 커널 영역에 접근할 수 없도록 나누어 사용

---

### 유저영역의 메모리

<img src="https://velog.velcdn.com/images/shindoyeon/post/c03ea346-a236-49db-b4f6-93cd66d97491/image.png">

- **Code 영역 :** 실행할 프로그램의 코드
    
    : 사용자가 작성한 프로그램 함수들의 코드가 기계어 명령 형태로 변환되어 저장
    
    - 컴파일 타임에 결정
    - 중간에 코드 바꿀 수 없도록 Read-Only
    
- **Data 영역 :** 프로그램이 사용하는 데이터 ( 전역 혹은 정적 변수 )
    - 전역 혹은 정적 변수 참조한 코드는 컴파일 완료 시 data 영역의 주소값 가르킴
    - 프로그램 시작 시 할당 / 종료 시 해제
    - 전역 변수 변경 가능성 → Read-Write
    
- **Heap 영역 :** 프로그래머가 필요할 때마다 사용
    - 동적으로 할당, new로 생성한 객체가 많을 수록 크기 늘어남
    - 런타임에 크기 결정
    - 메모리의 낮은 주소부터 할당되는 선입선출 ( FIFO ) 구조
    
    ---
    
    **⁉️ 메모리의 힙 영역을 너무 크게 잡으면?**
    
    ✅ 
    
    1. GC ( Garbage Collection )이 느려질 수 있다!
        
        💡GC 란 ??
        
        스택과 다르게 힙은 참조가 끝나도 객체가 자동으로 사라지지 않음 ( = 메모리 누수 )
        
        → 더 이상 참조되지 않는 객체를 GC가 찾아서 제거하는 것
        
        힙 전체를 스캔하는 데에 시간이 오래 걸리기 때문에 GC가 느려짐
        
    2. 메모리 누수가 있어도 GC가 느려 문제를 늦게 인지 → 장애가 터질 위험이 있다!
    3. 객체가 메모리에 넓게 퍼져 효율이 감소하고 애플리케이션 체감 성능이 저하된다 !
    
    👉🏻  Java의 JVM : 힙 영역 크게 잡지 않고 꽉 차면 → GC → 힙 확장 → …
    
    ---
    

- **Stack 영역 :** 함수 호출과 관력된 데이터를 저장
    
    ( == Call stack ) 호출 데이터를 담는 스택
    
    - 지역변수, 매개변수, 리턴값 등을 임시 저장
    - 함수 호출 시 할당 / 함수 호출 종료 시 해제
    - 컴파일 타임에 크기 결정 → 따라서 무한정 할당 불가능
    - 메모리의 높은 주소부터 할당되는 후입선출 ( LIFO ) 구조

---

**💡 컴파일 타임**

: 작성한 소스코드가 기계가 읽을 수 있는 형태로 변환되는 과정

**💡 런타임**

: 컴파일 과정을 마친 컴퓨터 프로그램이 실행되고 있는 환경, 또는 동작되는 동안의 시간

---

- **Heap Overflow, Stack Overflow**
    - Heap 영역과 Stack 영역은 같은 공간을 공유함
        - 힙은 선입선출 구조 → 주소값이 낮은 위쪽주소부터 아래로
        - 스택은 후입선출 구조 → 주소값이 높은 아래쪽주소부터 위로
    
    ‼️ 각 영역이 상대 공간을 침범하는 일 발생할 수 있음
    
    - 힙 오버플로우 / 스택 오버플로우 : 스택이 크면 힙이 작고 힙이 크면 스택이 작음

### 메모리의 종류

CPU에 가까운 순서대로 레지스터 > 캐시 > 주기억장치 > 보조기억장치

CPU에 가까울수록 접근 속도가 빠름

### 캐시 메모리

: 메인 메모리에 저장된 내용의 일부를 임시로 저장해 두는 기억장치

CPU - 메인 메모리의 속도 차이로 인한 성능 저하를 방치함

<aside>
💡

**CPU와 캐시의 상호작용**

- CPU에서 주소 전달 → 캐시 메모리에 명령어가 존재하는지 확인
    - (존재) Hit → 해당 명령어를 CPU로 전송 → 완료
    - (비존재) Miss → 명령어를 포함한 메인 메모리에 접근 → 해당 명령어를 가진 데이터 인출 → 해당 명령어 데이터를 캐시에 저장 → 해당 명령어를 CPU로 전송 → 완료
</aside>

📌 캐시는 메인 메모리보다 작기 때문에 앞으로 사용될 것으로 예상하는 데이터를 미리 저장하는 것이 중요한 포인트 !

---

**⁉️ 어떻게 해야 CPU가 원하는 데이터가 캐시되어있을 확률을 높일 수 있을까?**

✅ CPU가 어떤 데이터를 원할지 어느 정도 예측할 수 있어야함.

—> 적중률 극대화 == **‘** **지역성의 원리 ‘**

- 시간 지역성 : 최근에 참조된 주소의 내용은 곧 다음에도 참조된다
- 공간 지역성 : 실제 프로그램이 참조된 주소와 인접한 주소의 내용은 다시 참조된다

---

# 2. 메모리 관리

: 물리적 주소를 갖는 메모리 공간에서 여러개의 프로세스를 어떻게 같이 돌릴 것인가

---

**⁉️ 왜 OS가 메모리 관리를 해야할까?**

✅ 각각의 프로세스는 독립된 메모리 공간을 가지고 있음 ( 다른 프로세스에 접근 불가 )

→ 운영체제 만이 커널 영역, 사용자 영역의 접근에 영향을 받지 않고 메모리 관리가 가능

---

## 메모리 관리 전략 1) : 주소 바인딩

( Address Binding )

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FVXqac%2Fbtrf1h0DcjO%2FAAAAAAAAAAAAAAAAAAAAAPkC0uUGifk5opSH-tKtBdIt1mk-IYufm1J1CFIDjUGi%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1767193199%26allow_ip%3D%26allow_referer%3D%26signature%3DX5TmbHLCVxkExRcOuwUj1ST5a4Q%253D">

CPU가 프로세스 작업을 실행하기 위해서는 논리적 주소만으로는 실제 메모리 주소 모름

→ 따라서 논리적 주소 - 물리적 주소 매핑해주는 작업이 필요

== 주소 바인딩 !!

---

💡 논리적 주소

: CPU에 의해서 가상으로 생성되는 주소 체계, 물리적 주소와 매핑하여 사용

**→ 매핑해주는 장치 = MMU ( 메모리 관리 장치 )**

---

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FdOf2Pi%2FbtrrqmQrCXo%2FAAAAAAAAAAAAAAAAAAAAAH1rhitFELMU2Lm9srDtKOd4ncnVkfX9WUACOhPQxe2T%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1767193199%26allow_ip%3D%26allow_referer%3D%26signature%3DZdXJlpC3PtOrlBMqY4Lo2P%252FtZDE%253D">

- **컴파일 타임 바인딩** : 컴파일할 때 물리적 주소 결정
    - 일단 여기부터 여기까지는 메모리에 이 프로세스 올려버릴게 ~~
    
    **🤮 ❌ 현재 많이 사용하지 않음.**
  
    → 현재 우리의 컴퓨터는 한 가지 프로세스만 실행시키지 않기 때문에 물리적 주소 바로 사용하면 다른 프로세스와 메모리 겹칠 수 있음.
    
- **로드 타임 바인딩** : 프로세스의 실행이 시작될 때 물리적 주소 결정
    - 프로세스 안에서 사용하는 메모리 주소 ( 논리 주소 )를 프로세스 전체를 로딩할 때 프로세스가 로딩되는 위치에 따라 물리적 주소를 매핑해주는 것
    
     **🤮 ❌  현재 많이 사용하지 않음.**
    
    → 프로세스 내에 메모리를 참조하는 명령어들이 많아서 프로세스 실행될 때마다 이 많은 주소들을 다 바꿔줘야하기 떄문에 로딩할 때의 시간이 매우 커짐
    
- **✅ 런타임 바인딩 : 프로그램 실행 후 물리적 주소 변경 가능한 방식**
    - CPU가 주소를 참조할 때마다 해당 데이터가 물리적 주소의 어느 위치에 있는지 주소 매핑 테이블을 이용하여 확인함
    - 하드웨어를 이용하여 작업을 수행함 !
        
        **== MMU ( 메모리 관리 장치 !! )**
        
    
    ### MMU ( Memory Mangement Unit )
    
    CPU 코어 안에 탑재되어 논리적 주소로부터 물리적 주소 공간 지정해주는 레지스터
    
    Relocation Register, Limit Register, MMU register
    
    : 기준 레지스터 값 + 논리적 주소 값 = 주소 바인딩
    

## **❌** 메모리 관리 전략 2) : 스와핑

( Swapping )

프로세스가 실행되려면 반드시 메모리에 올라가야함

‘프로세스가 스와핑한다’ == 현재 메모리에서 잠깐 다른 저장공간으로 옮겼다가, 돌아왔다

→ 실행에 따라 교체될 수 있다

- 보조기억장치 ( secondary/ Backing stroage ) : 잠깐 빼놓는 공간
- **swap-out** : 메인 메모리에서 보조기억장치로
- **swap-in** : 보조기억장치에서 메인 메모리로

EX ) 어떤 10개의 프로세스가 유저 영역에 있음, 메모리는 10개까지만 실행 가능

꽉 차 있는 상태에서 11번째 프로세스가 실행됨

→ 10개 중  가장 안 쓰는 프로세스( 2번이라고 가정 )를 잠깐 빼서 보조기억장치에 넣음 

→ 11번째 프로세스 실행

몇시간이 지나고 2번 프로세스 이벤트 요청옴

→ 2번 프로세스 메모리로 복귀

**swap-in, swap-out를 반복하는 과정이 스와핑이다~**

---

**⁉️ 현재는 스와핑을 사용할까?**

**🤮 ❌  사용하지 않는다.** 

### 문제점‼️ : 단편화 ( Fragmentation )

: 프로세스들이 메모리(RAM)에 적재되고 제거되는 일이 반복되면 프로세스들이 차지하는 메모리 틈 사이에 사용하기에 애매한 작은 공간들이 늘어남!

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FbpWfjM%2Fbtrf3xI9oH6%2FAAAAAAAAAAAAAAAAAAAAACMuzpwGk7u_1jpp6Mii1p8iQe5JT4DFcfs6TZpiddNO%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1767193199%26allow_ip%3D%26allow_referer%3D%26signature%3DrwIsDxYcO65Ae%252BqWNAupSN%252BKN3U%253D">

- **내부 단편화**
    
    : 할당된 메모리 블록 안에서 사용되지 못하고 남아버리는 공간
    
    - 1000 크기의 분할에 990 프로세스 넣으면 10 남는 경우
- **외부 단편화**
    
    : 총공간을 계산했을 때 프로세스가 들어갈 수 있는 메모리가 있는데 공간들이 연속하지 않아서 사용할 수 없는 경우
    

---

### + )가상 메모리 ( Virtual Memory )

: 메모리가 실제 메모리보다 많아 보이게 하는 기술

어떤 프로세스가 실행될 때 메모리에 해당 프로세스 전체가 올라가지 않아도 실행 가능

→ 애플리케이션이 실행될 때 **실행에 필요한 부분만 메모리에, 나머지는 디스크에 !!**

( 디스크가 마치 보조기억장치의 역할 )

**‼️ 빠르고 작은 RAM + 크고 느린 디스크 = 가상메모리**

---

## ( 가상 ) 메모리 관리 전략 3) : 메모리 할당 방식

- 연속방식
    - 고정 길이 할당 : 메모리를 고정된 길이로 분리 → **내부 단편화 발생**
    - 가변 길이 할당 : 가변적인 길이 할당으로 인해 일부분이 빈다 → **외부 단편화 발생**
- 불연속 방식 ( == 단편화 해결방법 ! )
    
    **👇🏻 단편화 해결방법**
    
    ### ✅ 외부 단편화 해결 ) : 페이징 기법
    
    - 페이지 : 가상메모리를 같은 크기의 블록으로 나눈 것
    - 프레임 : RAM을 페이지와 같은 크기의 블록으로 나눈 것
    
    <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FkDvX0%2FbtrfV8jnwx8%2FAAAAAAAAAAAAAAAAAAAAAIv8vhqzOzlQpzo_GgGT9gymdTRwwmhsmL7nL3Yr1Dqq%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1767193199%26allow_ip%3D%26allow_referer%3D%26signature%3DALm%252FU9jh9iI7OyuZ7tj96xbX%252BHI%253D">
        
    **한 프로세스가 사용하는 공간을 여러 페이지로 나누고 → 페이지-프레임을 매핑하여 저장**
    
    ‼️ 페이지가 순서대로 메모리에 저장되지 않음
    
    → 페이지가 어느 프레임에 들어있는지 page table라는 테이블에 저장해야함
    
    이 테이블을 참고하여 논리적 주소 → 물리적 주소로 변환하는 것
    
    - 장점
        - 외부단편화 해결 : 페이지들이 연속할 필요가 없기 때문에 공간에 순서없이 들어가도 됨 → 불필요한 공간이 남지 않음
    - 단점
        - 내부단편화 해결못함 : 페이지, 프레임 크기가 고정적임
            
            EX ) 프로세스가 필요한 메모리가 만약 18KB이라고 가정
            
            페이지와 프레임 크기는 무조건 4KB로 고정되어있음
            
            → 페이지와 프레임 크기 때문에 마지막 페이지(프레임)에서는 무조건 2KB가 남아버림.. ( 4*5 = 20KB, 20-18 = 2KB )
            
        - page table 저장 위한 메모리 소모
        - page table 접근 + 실제 연산으로 인해 속도 저하
    
    ### ✅ 내부 단편화 해결 ) : 세그멘테이션 기법
    
    **가상 메모리를 크기가 다른 논리적 단위의 세그먼트로 분할 → 메모리 할당 → 실제 메모리 주소로 변환**
    
    - 각 세그먼트는 연속적인 공간에 저장되어 있음
    - 분할 방식 외에는 동작 방식이 비슷함 → 세그먼트 테이블을 이용하여 매핑
    - 장점
        - 내부단편화 해결 : 세그먼트의 크기가 서로 다름
        - 프로그램의 중요한 부분, 중요하지 않은 부분 분리 저장 가능
    - 단점
        - 외부단편화 해결못함 : 세그먼트가 연속적으로 저장되어야함
    
---    
- 메모리 할당 규칙
    - 최초 적합 ( First Fit )
        - 메모리 내 빈 공간 순서대로 검색, 적재할 수 있는 공간 발견 시 바로 프로세스 배치
        - 검색 최소화, 빠른 할당
    - 최적 적합 ( Best Fit )
        - 빈 공간 모두 검색 후, 가장 작은 공간에 할당
        - 검색 시간 늘지만 메모리 단편화 최소화
    - 최악 적합 ( Worst Fit )
        - 빈 공간 모두 검색 후, 가장 큰 공간에 할당
        - 검색 시간, 메모리 단편화 극대화
## ( 가상 ) 메모리 관리 전략 4) : 요구 페이징

( demand paging )

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FbO1hx2%2FbtqAMlIlCm5%2FAAAAAAAAAAAAAAAAAAAAAJZefRkE0ktm1PcEKXJCxReJ1Y2b5Q5feXRLfoeq2e_c%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1767193199%26allow_ip%3D%26allow_referer%3D%26signature%3DyDEv4i2FUoXEnFNsZu5mqRfaoNk%253D">

**프로세스가 실행되는 동안 필요한 페이지만 메모리에, 필요하지 않은 페이지는 디스크에 !**

### Valid-Invalid Bit

요구 페이징 사용 시 필요한 페이지가 메모리에 있을수도, Backing Store에 있을수도 있음.

→ 페이지가 메모리에 적재되어 있는지 판단할 방법이 필요함

valid ( 1 ) : 페이지가 메모리에 존재한다

valid ( 0 ) : 페이지가 메모리에 존재하지 않는다 - - > Pafe Fault 가 발생했다 !

### 페이지 부재 ( Page Fault )

프로세스가 실행되는 도중에 필요한 페이지가 물리 메모리에 존재하지 않아 디스크에서 해당 페이지를 가져와야하는 경우

- 메모리에 빈 공간이 있다면
    - 디스크에서 해당 페이지를 읽어와 물리 메모리에 적재
- ⁉️ **메모리에 빈 공간이 없다면 ?!**
    
    **✅ 페이지 교체 알고리즘 사용**
    
    - 더 이상 사용되지 않는 페이지를 디스크로, 새로운 페이지를 메모리에 적재

### 페이지 교체 알고리즘

- FIFO : 가장 오래된 페이지를 교체한다.
- OPT(Optimal) : 가장 먼 미래 동안 사용되지 않을 페이지를 교체한다.(불가능)
- LFU(Least Frequently Use) : 가장 사용 빈도가 적은 페이지를 교체한다.
- MFU(Most Frequently used) : 가장 사용 빈도가 많은 페이지를 교체한다.
- LRU(Least Recently Use) : 가장 오랫동안 사용되지 않은 페이지를 교체한다.
- NUR(Not Used Recently)
    - LRU와 유사한 알고리즘으로, 가장 오랫동안 사용되지 않은 페이지를 교체한다.
    - 이를 확인하기 위해서 참조비트와 변형비트를 사용한다.
    - 참조 비트 : 페이지가 호출되지 않았을 때는 0, 호출되었을 때는 1
    - 변형 비트 : 페이지 내용이 변경되지 않았을 때는 0, 변경되었을 때는 1
    - 00인것이 가장 먼저 교체되버린다.
- Clock Algorithm
    - LRU와 유사한 알고리즘으로, 각 페이지가 최근에 참조되었는지 여부를 활용한다.
    - 페이지마다 reference bit을 갖고 있고, 초기에는 모두 0, 참조되면 1으로 변경된다.
    - page replacement가 진행되면 한쪽 방향으로 page table을 참조하기 시작하면서 1비트를 만다면 0비트로 내리고 0비트를 만나면 해당 페이지가 replacement 대상이 된다.
    - **가장 오랫동안 참조되지 않은 페이지를 찾을 수는 없지만, 가장 최근에 참조된 페이지는 피할 수 있다.**


# ⁉️ 예상 질문 모음

> **✅ 기술 면접 답변틀**
> 
> 1. 기술의 정의 
> 2. 어디에서 사용하는지
> 3. 어떻게 사용할 수 있는지

<aside>
💡

**힙 영역과 스택영역의 차이점을 설명하시오.** 

**메모리의 구조를 영역에 따라 설명**

**메모리의 힙 영역과 스택 영역의 차이에 대해 설명해주세요.**

**메모리의 힙 영역을 너무 크게 잡으면 어떤 일이 생길까요?**

**가상메모리가 무엇인지 설명해주세요**

- **가상 메모리가 탄생하게 된 배경에 대해 설명해주세요.**
- **요구 페이징이 무엇인지 설명해주세요**
- **페이지 교체 알고리즘이란 무엇인가요?**
- **페이지 교체가 언제 발생하는지 설명해주세요.**
- **어떤 교체 알고리즘이 있는지 설명해주세요**

**Swapping 이란 무엇인가요?**

- **Swapping을 하면서 발생하는 문제점에 대해 설명해주세요.**
- **내부 단편화와 외부단편화가 무엇인지 설명해주세요**
- **외부 단편화를 해소하기 위한 방법은 무엇이 있을까요?**
- **페이징과 세그멘테이션에 대해 설명해주세요.**

**Thrashing ( 쓰레싱 ) 에 대해 설명해주세요**

**메모리가 고갈되면 일어나는 현상에 대해 설명해주세요**

**캐시 메모리가 무엇인가요**

- **캐시 메모리에서 가장 신경써야 하는 문제는 무엇인가요?**
- **적중률(hit rate)을 극대화 시키기 위한 방법은 무엇인가요?**
- **캐시의 지역성에 대해 설명해주세요.**

**DMA 에 대해 설명해주세요**

**메모리 할당 중, 연속 방식과 불연속 방식에 대해 설명해주세요**

</aside>
