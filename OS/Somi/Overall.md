지금까지 공부한 **OSI 7계층이 이론이라면, 운영체제는 현실**이다.

OSI 7계층이 네트워크 통신을 설명하기 위한 개념적 모델이라면, 운영체제는 그 모델을 실제로 구현, 관리하는 주체이다.

‼️ 운영체제는 네트워크 통신을 위해 ‘네트워크 스택’ 을 내부에 가지고 있음

→ 이 스택이 OSI 계층의 하위 계층들을 실제 코드로 구현한 것

```java
[ 애플리케이션 ]
   └─ HTTP, WebSocket, gRPC
      (OSI 7~5, 앱 영역)

[ 운영체제 커널 ]
   └─ TCP / UDP (OSI 4)
   └─ IP / ICMP (OSI 3)

[ 드라이버 / 하드웨어 ]
   └─ Ethernet, Wi-Fi (OSI 2)
   └─ 전기적 신호 (OSI 1)
 
 ( 주의 : 출처 지피티 .. )
```

<aside>
💡

지피티가 말해주는 면접에서 점수 올라가는? 말 ……

- OSI 계층 ≠ 실제 구현 단위
    - OSI 7계층은 논리적 분류이고 운영체제는 계층을 묶어서 네트워크 스택으로 구현한다
- 개발자는 OSI 2-4계층까지만 간접적으로 다룸
    - TCP/UDP → OS가 처리 ( 전송계층에서 가장 핵심 역할 )
    - 개발자는 소켓 API만 사용
- OS는 네트워크 통신의 관리자
    - 패킷 분할/재조립, 포트 충돌 관리, 재전송/순서 보장, 네트워크 자원 보호
</aside>

# 운영체제란?

운영체제 ( Operating System )

: 컴퓨터의 핵심 소프트웨어,  컴퓨터 하드웨어 - 응용 프로그램 간의 상호작용을 관리하고 제어하는 역할

### 목적

- 사용자와 하드웨어 사이의 인터페이스를 제공해 효율적으로 응용 프로그램이 동작하도록 지원
- 시스템 자원을 효율적으로 관리하여 응용 프로그램이 원활하게 동작

### 주요 구성요소

<img src="https://static.wikidocs.net/images/page/230921/%EA%B7%B8%EB%A6%BC2.png">
- 커널 ( Kernel ) : 운영체제의 핵심 부분, 시스템의 기본적인 작업 관리
    - 사용자와 상호작용 없이 백그라운드에서 실행
- 쉘 ( Shell ) : 사용자와 커널 사이의 인터페이스
    - 사용자에게 명령 받아 커널에 전달, 그 결과를 사용자에게 출력 ( GUI, CUI .. )
    - == 명령 해석기
- 시스템 콜 ( System call ) : 운영체제가 커널에 접근하기 위한 인터페이스
    - 유저 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출할 때 사용

### 역할

1. CPU 스케줄링, 프로세스 관리
    
    CPU 소유권을 어떤 프로세스에서 할당할지, 프로세스 생성 , 삭제, 자원 할당 및 반환 관리
    
2. 메모리 관리
    
    한정된 메모리를 어떤 프로세스에 얼만큼 할당해야할지 관리
    
3. 디스크 파일 관리
    
    디스크 파일을 어떤 방법으로 보관할지 관리
    
4. 하드웨어 관리 및 하드웨어 인터페이스 제공
    
    I/O 디바이스인 마우스, 키보드와 컴퓨터 간 데이터를 주고받는 것을 관리하고 복잡한 과정 없이 하드웨어 장비를 사용할 수 있도록 인터페이스 ( 소프트웨어 ) 제공
    

# keyword 1: 프로세스

: 실행 중인 프로그램, 운영체제에 의해 관리되는 독립적으로 실행되고 자원을 할당받을 수 있는 단위

**EX )** 

1. 엑셀을 실행시키기 위해 컴퓨터는 엑셀 프로그램을 읽어야 함
2. 코드로 되어있는 엑셀 프로그램을 컴퓨터가 읽으려면 CPU가 이해할 수 있는 형태인 0과 1로 이루어진 기계어로 프로그램이 만들어져야 함
    - 0과 1로 작성된 실행 프로그램
        
        : 코드 이미지 또는 바이너리라고 부르며, 보통 exe란 확장자 사용
        
3. 이 exe 프로그램을 실행하면 메모리에 실행할 데이터가 올라가고, CPU가 이 데이터의 코드를 한줄씩 읽어 나가며 실행
    
    ‼️ 이때, **메모리에 올려진 데이터를 프로세스**라고 한다.
    

# keyword 2: 메모리

: 프로그램을 실행하기 위해선 먼저 프로그램이 메모리에 로드되어야함

→ 운영체제는 이를 위해 다양한 메모리 공간을 제공하고, 각각의 메모리 공간은 상호 작용하며 프로그램 실행에 기여함

<img src="https://velog.velcdn.com/images/shindoyeon/post/c03ea346-a236-49db-b4f6-93cd66d97491/image.png">

- Heap 영역과 Stack 영역은 사실 같은 공간을 공유함
    - heap이 메모리 위쪽 주소부터 할당되면, stack은 아래쪽부터 할당되는 식임
    
    → 상태 공간을 침범하는 일 발생 !!
    
    이를 각각 Heap Overflow, Stack Overflow라고 칭함
    

# keyword 3 :  CPU 스케줄링

: CPU 스케줄링은 언제 어떤 프로세스에 CPU를 할당할지 결정하는 작업

→ 이용률은 높게

→ 주어진 시간에 많은 일을 하도록

→ 준비 큐에 있는 프로세스는 적게

→ 응답 시간은 짧게

```java
** CPU 스케줄러는 언제 스케줄링을 결정하는가?

1) 실행(running) 상태에서 대기(waiting) 상태로 전환(switching)될 때

2) 실행(running) 상태에서 준비(ready) 상태로 전환(switching)될 때 

3) 대기(waiting) 상태에서 준비(ready) 상태로 전환(switching)될 때

4) 종료(Terminated)될 때
```

- 1,4 상황에서만 스케줄링이 발생하는 것 : **비선점형 스케줄링**
이 외의 모든 스케줄링 : **선점형 스케줄링**

# keyword 4 : 병행 제어

- 병행성이란 ?
    - 두 개 이상의 프로세스들이 동시에 존재하고, 병렬적으로 실행될 수 있는 상태
- 병행성 제어란 ?
    - 컴퓨터는 한정된 자원 ( CPU , 메모리 , 디스크 등 ) 을 사용해야함
    - 프로세스가 여러개 동시에 작업되는 경우 충돌 발생 가능
        - 이를 해결하기 위해 상호 배제, 임계 영역, 동기화 등으로 제어할 수 있음

keyword )

Multiple-Processor Scheduling, Asymmetric Multiprocessing, Symmetric Multiprocessing, Real-Time CPU Scheduling, Minimizing Latency (지연시간 최소화), Priority-Based Scheduling, Rate-Monotonic Scheduling

Process Synchronization(프로세스 동기화), Deadlock …
