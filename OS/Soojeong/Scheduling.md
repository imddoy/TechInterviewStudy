### CPU 스케줄링: 운영체제가 한정된 CPU를 나누는 방법

운영체제의 가장 핵심적인 역할 중 하나는 한정된 자원을 여러 프로세스에게 어떻게 배분할 것인지예요.
그중에서도 CPU는 모든 작업의 중심이 되는 자원이기 때문에, CPU를 누구에게 언제 할당하느냐는 시스템 성능과 직결돼요.

이 글에서는 CPU 스케줄링이 왜 필요한지부터,
프로세스 상태와 스케줄링 큐, 선점 여부, 그리고 대표적인 CPU 스케줄링 알고리즘까지 단계적으로 정리해볼게요.

### CPU 스케줄링이란?

**CPU 스케줄링(CPU Scheduling)** 이란
운영체제가 여러 프로세스들 사이에서 CPU 자원을 공정하고 효율적으로 배분하기 위해 사용하는 정책을 의미해요.

처음에는 “CPU를 쓰고 싶은 프로세스를 순서대로 실행하면 되지 않을까?”라는 생각이 들 수 있어요.
하지만 실제 시스템에서는 이런 방식이 비효율적이에요.

그 이유는 다음과 같아요.

- 모든 프로세스의 중요도가 같지 않아요.
- 즉각적인 반응이 필요한 프로세스가 있어요.
- CPU를 오래 점유하는 프로세스가 있어요.
- CPU보다 입출력 작업이 많은 프로세스도 있어요.

그래서 운영체제는 단순한 실행 순서가 아니라,
프로세스의 특성과 시스템 상황에 맞게 CPU를 배분해야 해요.

### 프로세스 우선순위와 CPU / I-O 특성

1. 프로세스 우선순위 (Priority)

운영체제는 각 프로세스에 **우선순위(priority)** 를 부여해요.
이 우선순위는 사용자가 직접 설정할 수도 있고, 운영체제가 내부 정책에 따라 자동으로 정할 수도 있어요.

프로세스의 우선순위 정보는 **PCB(Process Control Block)** 에 저장돼요.

일반적으로 우선순위가 높을수록
CPU를 더 빨리, 더 자주 할당받을 가능성이 높아요.

2. I/O Bound 프로세스와 CPU Bound 프로세스

프로세스는 CPU와 입출력 장치를 사용하는 방식에 따라 크게 두 가지로 나눌 수 있어요.

### I/O Bound Process (입출력 집중 프로세스)

입출력 작업이 많고,
CPU를 잠깐 사용한 뒤 바로 대기 상태로 전환되는 경우가 많아요.

예를 들면 영상 스트리밍, 파일 다운로드, 디스크 백업 같은 작업들이 이에 해당해요.

이런 프로세스는 실행 상태보다 대기 상태에 머무르는 시간이 더 길어요.
대기 상태에서는 CPU를 사용하지 않기 때문에,
CPU를 요청했을 때 빠르게 처리해주는 것이 전체 시스템 성능에 유리해요.

그래서 I/O 집중 프로세스는 일반적으로 우선순위가 높게 설정돼요.

### CPU Bound Process (CPU 집중 프로세스)

연산 작업이 많고,
CPU를 오랫동안 점유하는 특징을 가져요.

컴파일 작업, 수치 계산, 그래픽 처리 같은 작업들이 여기에 해당해요.

이런 프로세스는 한 번 CPU를 할당받으면 비교적 오래 사용하기 때문에,
I/O 집중 프로세스에 비해 우선순위가 상대적으로 낮게 설정되는 경우가 많아요.

핵심은 운영체제가 CPU와 입출력 장치가 놀지 않도록 하기 위해
I/O 집중 프로세스를 우선 실행하는 전략을 사용한다는 점이에요.

### 스케줄링 큐(Scheduling Queue)

운영체제는 모든 프로세스의 PCB를 매번 확인하면서 CPU를 배분하지 않아요.
그렇게 하면 시간이 너무 오래 걸리고 비효율적이에요.

그래서 운영체제는 **스케줄링 큐(scheduling queue)** 를 사용해서
자원을 이용하고 싶어 하는 프로세스들을 관리해요.

스케줄링 큐는 말 그대로
"자원을 사용하기 위해 줄을 서는 공간"이라고 볼 수 있어요.

- 준비 큐(Ready Queue)

  준비 큐는 CPU를 할당받기 위해 기다리는 프로세스들이 들어가는 큐예요.
  이 큐에 있는 프로세스들은 모두 **준비 상태(Ready state)** 에 있어요.

  언제든 CPU를 할당받으면 실행 상태로 전환될 수 있는 프로세스들이에요.

- 대기 큐(Waiting Queue)

  대기 큐는 입출력 장치를 사용하기 위해 기다리는 프로세스들이 들어가는 큐예요.

  이 큐에 있는 프로세스들은 **대기 상태(Blocked state)** 에 있어요.

입출력 장치는 종류가 다양하기 때문에, 대기 큐도 장치별로 각각 존재해요.

예를 들면 하드디스크 대기 큐, 프린터 대기 큐, CD-ROM 대기 큐 등이 있어요.

입출력 작업이 완료되면 입출력 완료 인터럽트가 발생하고,
운영체제는 해당 대기 큐에서 작업이 끝난 프로세스를 찾아
상태를 대기 상태에서 준비 상태로 변경한 뒤 준비 큐로 이동시켜요.

중요한 점은,
큐에 먼저 들어갔다고 해서 반드시 먼저 CPU를 할당받는 것은 아니라는 거예요.
실제 실행 순서는 스케줄링 알고리즘과 우선순위에 따라 결정돼요.

### 프로세스 상태 변화

프로세스는 실행되는 동안 여러 상태를 오가요.

- 준비 상태: CPU를 할당받기 위해 준비 큐에서 대기하는 상태예요.
- 실행 상태: CPU를 할당받아 실제로 실행 중인 상태예요.
- 대기 상태: 입출력 작업이 끝나기를 기다리는 상태예요.

실행 상태의 프로세스는
타이머 인터럽트가 발생하면 다시 준비 상태로 돌아가고,
입출력 요청을 하면 대기 상태로 전환돼요.

입출력 작업이 완료되면
대기 상태에 있던 프로세스는 다시 준비 상태가 돼요.

### 선점형 스케줄링과 비선점형 스케줄링

CPU 스케줄링은
현재 실행 중인 프로세스로부터 CPU를 강제로 빼앗을 수 있는지에 따라
선점형 스케줄링과 비선점형 스케줄링으로 나뉘어요.

- 선점형 스케줄링(Preemptive Scheduling)

  선점형 스케줄링은 운영체제가 실행 중인 프로세스로부터 CPU를 강제로 회수해서
  다른 프로세스에 할당할 수 있는 방식이에요.

  우선순위가 더 높은 프로세스가 등장하면
  현재 실행 중이던 프로세스는 중단되고 CPU를 넘겨줘요.

  이 방식은 특정 프로세스가 CPU를 독점하는 것을 막을 수 있고,
  응답 시간이 빠르다는 장점이 있어요.

  하지만 그만큼 문맥 교환(Context Switching)이 자주 발생해서
  오버헤드가 커질 수 있다는 단점도 있어요.

- 비선점형 스케줄링(Non-preemptive Scheduling)

  비선점형 스케줄링은 한 프로세스가 CPU를 사용하기 시작하면
  해당 프로세스가 종료되거나 대기 상태가 될 때까지 다른 프로세스가 CPU를 빼앗을 수 없는 방식이에요.

  문맥 교환이 적어서 오버헤드는 작지만, 하나의 프로세스가 CPU를 오래 점유하면
  다른 프로세스들이 오랫동안 기다려야 할 수 있어요.

### 대표적인 CPU 스케줄링 알고리즘

CPU 스케줄링 알고리즘은 여러 가지가 있고, 운영체제마다 서로 다른 방식을 사용해요.
아래는 대표적으로 많이 언급되는 스케줄링 알고리즘들이에요.

### 1. 선입 선처리 스케줄링 (FCFS: First Come First Served)

준비 큐에 먼저 삽입된 프로세스부터 CPU를 할당하는 방식이에요.
가장 단순한 형태의 비선점형 스케줄링이에요.

하지만 CPU 사용 시간이 긴 프로세스가 먼저 실행되면,
뒤에 있는 짧은 작업들이 오랫동안 기다리게 되는 문제가 있어요.
이 현상을 **호위 효과(Convoy Effect)** 라고 해요.

### 2. 최단 작업 우선 스케줄링 (SJF: Shortest Job First)

CPU 사용 시간이 가장 짧은 프로세스부터 실행하는 방식이에요.
FCFS에서 발생하는 호위 효과를 완화할 수 있어요.

다만 실제 환경에서는
프로세스의 정확한 CPU 사용 시간을 미리 예측하기 어렵다는 한계가 있어요.

### 3. 라운드 로빈 스케줄링 (RR: Round Robin)

라운드 로빈 스케줄링은
선입 선처리 스케줄링에 타임 슬라이스(time slice) 개념을 추가한 방식이에요.

각 프로세스는 정해진 시간만큼만 CPU를 사용하고,
시간이 끝나도 작업이 완료되지 않으면
준비 큐의 맨 뒤로 이동해요.

타임 슬라이스의 크기가 너무 크면 FCFS와 비슷해지고,
너무 작으면 문맥 교환 오버헤드가 커져요.

### 4. 최소 잔여 시간 우선 스케줄링 (SRT: Shortest Remaining Time)

최단 작업 우선 스케줄링을 선점형으로 확장한 방식이에요.
현재 실행 중인 프로세스보다
남은 CPU 시간이 더 짧은 프로세스가 도착하면
CPU를 선점해요.

### 5. 우선순위 스케줄링 (Priority Scheduling)

각 프로세스에 우선순위를 부여하고,
우선순위가 높은 프로세스부터 실행하는 방식이에요.

하지만 우선순위가 낮은 프로세스는
계속해서 실행이 미뤄질 수 있는데,
이를 기아(starvation) 현상이라고 해요.

이 문제를 해결하기 위해
오래 기다린 프로세스의 우선순위를 점차 높여주는
에이징(aging) 기법을 사용해요.

### 6. 다단계 큐 스케줄링 (Multilevel Queue)

우선순위별로 여러 개의 준비 큐를 두는 방식이에요.
우선순위가 가장 높은 큐에 있는 프로세스를 먼저 실행하고,
해당 큐가 비어 있을 때만 다음 큐를 처리해요.

큐 간 이동은 기본적으로 허용되지 않아요.

### 7. 다단계 피드백 큐 스케줄링 (Multilevel Feedback Queue)

다단계 큐 스케줄링을 확장한 방식이에요.
큐 간 이동이 가능하다는 점이 가장 큰 특징이에요.

CPU를 오래 사용하는 프로세스는 점점 낮은 우선순위 큐로 이동하고,
낮은 우선순위 큐에서 오래 기다린 프로세스는 다시 높은 우선순위 큐로 이동할 수 있어요.

이 방식은 CPU 집중 프로세스와 I/O 집중 프로세스의 특성을
자연스럽게 반영할 수 있어서 현대 운영체제에서 널리 사용돼요.

---

면접 질문 (질문 + 답변)

1. CPU 스케줄링이 필요한 이유는 무엇인가요?

   CPU는 한정된 자원이기 때문에 여러 프로세스가 동시에 사용할 수 없어요.
   그래서 운영체제는 CPU를 누구에게 언제 할당할지 결정해야 하고, 이를 위해 CPU 스케줄링이 필요해요.

   단순히 먼저 요청한 순서대로 실행하면 응답 시간이 길어지거나 특정 프로세스가 CPU를 독점할 수 있기 때문에, 프로세스의 특성과 시스템 상황에 맞게 CPU를 배분하는 정책이 필요해요.

2. 프로세스 우선순위는 왜 필요한가요?

   모든 프로세스의 중요도가 같지 않기 때문이에요.
   즉각적인 반응이 필요한 프로세스도 있고, 비교적 느리게 실행돼도 되는 프로세스도 있어요.

   운영체제는 프로세스마다 우선순위를 부여해서 중요한 작업이나 빠른 응답이 필요한 작업이 먼저 CPU를 할당받도록 해요.
   이 우선순위 정보는 PCB에 저장돼요.

3. I/O Bound 프로세스와 CPU Bound 프로세스의 차이는 무엇인가요?

   I/O Bound 프로세스는 입출력 작업이 많아서 CPU를 짧게 사용하고 대기 상태에 자주 들어가요.
   반면 CPU Bound 프로세스는 연산 작업이 많아서 CPU를 오랫동안 점유해요.

   I/O Bound 프로세스는 CPU를 요청했을 때 빠르게 처리해주는 것이 전체 시스템 성능에 유리하기 때문에, 일반적으로 CPU Bound 프로세스보다 우선순위가 높게 설정돼요.

4. 준비 큐와 대기 큐의 차이는 무엇인가요?

   준비 큐는 CPU를 할당받기 위해 기다리는 프로세스들이 들어 있는 큐예요.
   이 큐에 있는 프로세스들은 모두 준비 상태에 있어요.

   대기 큐는 입출력 장치를 사용하기 위해 기다리는 프로세스들이 들어 있는 큐예요.
   입출력 장치 종류별로 대기 큐가 따로 존재하고, 입출력 작업이 완료되면 대기 큐에서 준비 큐로 이동해요.

5. 선점형 스케줄링과 비선점형 스케줄링의 차이는 무엇인가요?

   선점형 스케줄링은 운영체제가 실행 중인 프로세스로부터 CPU를 강제로 빼앗을 수 있는 방식이에요.
   우선순위가 높은 프로세스가 등장하면 현재 실행 중인 프로세스는 중단돼요.

   비선점형 스케줄링은 한 프로세스가 CPU를 사용하기 시작하면 종료되거나 대기 상태가 될 때까지 CPU를 계속 사용해요.

   선점형은 응답성이 좋고, 비선점형은 문맥 교환 오버헤드가 적다는 특징이 있어요.

6. FCFS 스케줄링의 단점은 무엇인가요?

   FCFS 스케줄링의 가장 큰 단점은 호위 효과(Convoy Effect)예요.

   CPU 사용 시간이 긴 프로세스가 먼저 실행되면, 뒤에 있는 짧은 작업들이 오랫동안 기다려야 해요.
   이로 인해 평균 대기 시간이 증가하고 시스템 응답성이 떨어져요.

7. 라운드 로빈 스케줄링에서 타임 슬라이스의 크기가 중요한 이유는 무엇인가요?

   타임 슬라이스가 너무 크면 라운드 로빈이 FCFS와 거의 같아져서 응답성이 나빠져요.
   반대로 타임 슬라이스가 너무 작으면 문맥 교환이 자주 발생해서 오버헤드가 커져요.

   그래서 타임 슬라이스의 크기는 응답성과 오버헤드 사이의 균형을 고려해서 적절하게 설정해야 해요.

8. 우선순위 스케줄링에서 발생할 수 있는 문제는 무엇인가요?

   우선순위가 낮은 프로세스가 계속해서 CPU를 할당받지 못하는 기아(starvation) 현상이 발생할 수 있어요.

   우선순위가 높은 프로세스만 계속 실행되면 낮은 우선순위 프로세스는 준비 큐에만 머무르게 돼요.

9. 기아 현상을 해결하는 방법에는 무엇이 있나요?

   대표적인 방법은 에이징(aging)이에요.

   에이징은 오랫동안 대기한 프로세스의 우선순위를 점진적으로 높여주는 방식이에요.
   이를 통해 우선순위가 낮은 프로세스도 언젠가는 CPU를 할당받을 수 있게 돼요.

10. 다단계 피드백 큐 스케줄링이 많이 사용되는 이유는 무엇인가요?

    다단계 피드백 큐 스케줄링은 프로세스의 CPU 사용 패턴에 따라 우선순위를 동적으로 조정할 수 있기 때문이에요.

    CPU를 오래 사용하는 프로세스는 우선순위가 낮아지고, 오랫동안 기다린 프로세스는 다시 우선순위가 높아져요.

    이 방식은 CPU Bound 프로세스와 I/O Bound 프로세스의 특성을 자연스럽게 반영하고,
    기아 현상을 완화하면서 효율적인 CPU 사용이 가능해서 현대 운영체제에서 널리 사용돼요.
