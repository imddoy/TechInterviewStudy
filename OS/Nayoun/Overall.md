# 0. 운영체제란?

> CPU, 메모리, 보조기억장치, 입출력 장치 등과 같은 **컴퓨터 부품들을 관리**하고, **프로그램에 필요한 자원을 할당하고, 프로그램이 올바르게 실행 되도록 돕는** 프로그램!

<img width="413" height="437" alt="image" src="https://github.com/user-attachments/assets/b1dc4077-9ee7-4749-a0ab-28e0520d66b4" />

- 운영체제는 **커널 영역**에 적재되어, 사용자 영역에 적재된 프로그램들에 자원을 할당한다. 
- 예를 들어, 인터넷 / 메모장 / 워드를 실행했을 때, 이 프로그램들간의 메모리 주소가 겹치지 않도록 **적당한 공간에 프로그램들을 적재**하고,**프로그램들이 실행되면 CPU 자원을 할당**시켜 준다. 

## 커널

<img width="960" height="524" alt="image" src="https://github.com/user-attachments/assets/601df0cd-c012-48d8-a1c4-0f3cb3cde37f" />

- 운영체제의 핵심 구성 요소로, **CPU·메모리·파일 시스템 등 시스템 자원 관리를 담당**한다.  
- 시스템 자원 관리를 위한 모든 사용자 명령은 GUI 또는 CLI와 같은 인터페이스를 통해
커널의 **시스템 콜 형태로 전달**된다.  
- `GUI(Graphic User Interface)`와 `CLI(Command Line Interface)`는 직접 자원을 관리하지 않고,
**커널이 제공하는 시스템 콜을 호출하여 자원 관리 요청을 수행**한다.


> 그럼 왜 인터페이스가 직접 자원을 관리하지 않고, **커널이 제공하는 시스템 콜을 호출 하는 방식을 사용**할까?

**시스템 안정성과 보안 때문에!**
- 만약 application이 CPU, 메모리, 하드 디스크 등에 마음대로 접근하고 조작할 수 있다면 자원이 무질서하게 관리될 것이다. 
- 그래서 application들이 자원에 접근하려고 할때, 오직 자신을 통해서만 접근하도록 하여 자원을 보호하는 것이다!


## System call & Dual Mode Structure

- 응용 프로그램이 실행되는 과정에서 파일 저장과 같이 **하드 디스크(HDD)에 접근**해야 하는 경우, 응용 프로그램은 하드웨어에 직접 접근할 수 없으므로 **운영체제에 도움을 요청**한다.
- 이 요청은 `시스템 콜(system call)` 의 형태로 전달되며, 운영체제는 **커널 영역에서 해당 작업을 수행하여 응용 프로그램의 요청을 대신 처리**한다.

이처럼 운영체제는 시스템 자원의 보호와 안정적인 관리를 위해 **이중 모드(Dual Mode) 구조**를 통해 보안을 구현한다.

### 1. 사용자 모드
- 일반적인 응용 프로그램이 실행되는 모드이다.
- GUI, CLI, 웹 브라우저, IDE, 게임 등 대부분의 프로그램이 사용자 모드에서 실행된다.
- CPU, 메모리, 디스크와 같은 시스템 자원에 직접 접근할 수 없다.
- 하드웨어 I/O 명령을 실행할 수 없다.
- 사용자 입력 처리, 연산, 로직 수행 등 제한된 작업만 수행 가능하다.

👉 사용자 모드는 시스템 안정성을 보장하기 위해 권한이 제한된 실행 환경이다.

### 2. 커널 모드

- 운영체제의 핵심 기능이 수행되는 특권 모드이다.
- 다음과 같은 시스템 자원 관리 기능을 담당한다.

1. CPU 제어 및 스케줄링
2. 메모리 관리
3. 파일 시스템 접근
4. 프로세스 및 스레드 관리
5. 모든 하드웨어 명령 실행

= 시스템 콜을 통해서만 사용자 모드로부터 진입할 수 있다.

👉 커널 모드는 시스템 자원에 대한 완전한 접근 권한을 가진다.


### 3. 사용자 모드 <-> 커널 모드 전환 과정

<img width="1140" height="412" alt="image" src="https://github.com/user-attachments/assets/04b317e8-9698-439c-8371-653129a37bed" />

사용자 모드 상태의 응용 프로그램이 시스템 콜을 요청하면 **CPU 실행 모드가 커널 모드로 전환**되고, **커널은 하드웨어에 직접 접근하여 운영체제의 핵심 기능을 수행한 후 다시 사용자 모드로 복귀**한다.

여기서 `System Call`은 일종의 `Interrupt` 이기도 하다.


# 운영체제의 핵심 서비스

> 프로세스 관리, 자원 접근 및 할당, 파일 시스템 관리 등이 있다.

## 1. 프로세스 관리
- 실행 중인 프로그램을 프로세스라고 한다!
- 하나의 CPU는 한 번에 하나의 프로세스만 실행할 수 있기 때문에, CPU는 프로세스 간 전환을 반복한다. 
- 이때의 Problem : 각 프로세스는 상태도 (당장 실행 가능 or 불가능), 그리고 사용하는 자원도 (CPU? I/O system?)도 다르다.

> 따라서 OS는 프로세스 관리 기능을 제공함으로서 여러 프로세스를 안전하고 효율적으로 관리한다!

### 1-1. Process Creation & Termination

<img width="800" height="400" alt="image" src="https://github.com/user-attachments/assets/48967800-ab38-4dc7-9949-ec37b8412faf" />

> 프로그램을 실행하면 새로운 프로세스가 생성되어야 하는데, 이떄 이전 작업들의 CPU, 메모리 등 자원을 회수해야 한다. 

- 따라서 OS는 프로세스 생성 (PID 부여 / 메모리 할당 / 초기 상태 설정을 해주고, 부모-자식 프로세스 간의 관계를 정리해주며, 그리고 프로세스 종료 시 자원을 정리해준다. 

1. 프로세스 생성 (`fork, exec`) -> PID 부여, 메모리 할당
2. 프로세스 종료 (`exit`)
3. 종료된 프로세스의 자원 정리
4. 부모 - 자식 프로세스 간의 관계 정리

등과 같은 작업을 해준다

**즉, 프로세스의 시작과 끝을 책임진다!**

### 1-2. Process State Management

<img width="839" height="573" alt="image" src="https://github.com/user-attachments/assets/bfe22da0-c8b3-454c-aca0-301c40d7285e" />

> 각 프로세스의 상태가 다른 문제를 해결하기 위해, OS는 프로세스의 상태를 구분하여 관리해준다. 

- 따라서 OS는

1. `New`
2. `Ready`
3. `Running`
4. `Waiting (Blocked)`
5. `Terminated`
등으로 프로세스의 상태를 구분하여 관리 하고 , 상태 전이를 제어해준다.

**즉, 지금 CPU를 받을 수 있는 프로세스가 누구인지 판단한다!**

### 1-3. CPU Scheduling

<img width="1064" height="582" alt="image" src="https://github.com/user-attachments/assets/3d69b23d-3cb2-42bc-a872-36f3210f2d2b" />

> 앞서 하나의 CPU는 한번에 하나의 프로세스만 실행 가능하다 했는데, OS는 이 CPU 작업들의 스케줄링을 해준다.

- 따라서 OS는

1. `Ready` 상태의 프로세스 중에서, 누가 먼저 얼마나 실행할지 결정시켜 준다.
2. 이 과정에서 스케줄링 알고리즘을 적용 시켜 준다 (FCFS, RR, Priority 등)

**즉 CPU 사용의 공정성과 효율성으 보장 시켜 준다!**

### 1-4. Context Switching

> CPU가 프로세스를 전환할 때, 이전 프로세스의 실행 정보를 잃으면 안된다.

- 따라서 OS는

현재 프로세스의 Context를 저장해주고 (ex) Register, Program Counter, Stack Pointer) 다음 프로세스의 Context를 복원시켜 준다.

**프로세스 전환이 가능하게 해준다!**

### 1-5. IPC, Inter-Process Communication


<img width="520" height="330" alt="image" src="https://github.com/user-attachments/assets/22bfe00f-cee6-484f-98b6-3dcd230b429f" />

> 프로세스는 서로 독립적인 주소 공간을 가진다고 했는데, 하지만 프로세스 간 통신이 필요한 경우도 있다.

- 따라서 OS는 
1. `Pipe`
2. `Message Queue`
3. `Shared Memory`
4. `Socket`
과 같은, 프로세스 간 통신 수단을 제공해 준다!

**프로세스의 독립성은 유지하면서, 통신 가능하게 해준다!**

### 1-6. Process Synchronization


<img width="907" height="440" alt="image" src="https://github.com/user-attachments/assets/8c8cb2c2-9fd5-429c-bc95-6fec66cb5fe1" />

> 앞서 각 프로세스가 사용하는 자원이 다르다고 했지만, 여러 프로세스가 공유 자원에 동시에 접근하는 경우도 있다.

- 따라서 OS는 데이터 불일치 문제를 해결하기 위해 다음과 같은 동기화 메커니즘을 제공해준다.
1. `Mutex`
2. `Semaphore`
3. `Monitor`

## 2. 자원 접근 및 할당

> 모든 프로세스는 자원을 필요로 하고, OS는 프로세스들이 사용할 자원에 접근하고 조작해줌으로서 프로세스에 필요한 자원을 할당한다. 그럼 OS는 CPU, Memory, I/O system을 어떻게 관리하고, 어떤 기능을 제공할 까?


### 2-1. CPU 관리 기능

<img width="651" height="386" alt="image" src="https://github.com/user-attachments/assets/4d448911-f570-4996-a8c8-a750256633e2" />

> 여러 개의 프로세스가, 하나의 CPU를 요구할 수 있다.

- 따라서 OS는
1. **CPU 스케줄링 :** 어떤 프로세스가 CPU를 사용할지 결정
2. **Time Sharing :** 짧은 시간 단위로 CPU를 나누어 사용
3. **선점 / 비선점 제어 :** 실행 중인 프로세스의 CPU 제어권 회수 가능

기능을 제공함으로서, 공정하게 CPU를 할당하고, 어떤 프로세스로부터 CPU를 이용하게 할 것인지, 그리고 얼마나 오래 CPU를 이용하게 할지를 결정해준다. 

### 2-2. Memory 관리 기능

<img width="555" height="511" alt="image" src="https://github.com/user-attachments/assets/c1f7dc45-b5e7-4311-ab68-13b13330ddc2" />

> 프로세스가 할당되는 메모리는 유한한 자원이고, (메모리 부족 현상 가능), 그리고 메모리에 잘못 접근하면 시스템에 치명적인 오류가 발생할 수 있다.

- 따라서 OS는
1. **메모리 할당 및 해제**
2. **주소 공간 분리 :** 각 프로세스는 독립적인 가상 주소 공간 보유
3. **가상 메모리 관리 :** 페이징, 세그먼테이션
4. **보호 및 접근 제어 :** 다른 프로세스 메모리 접근 차단

기능을 제공함으로서, 메모리 공간을 효율적으로 관리하고 프로세스에 알맞는 메모리를 할당한다. 

### 2-3. I/O System 관리 기능

> I/O 장치는 CPU보다 느리고 여러 프로세스가 공유하는 자원이며, 언제 작업이 완료될지 예측하기 어렵다. 만약 CPU가 I/O 작업이 끝날 때까지 직접 대기한다면 시스템 자원이 비효율적으로 사용된다.

- 따라서 OS는
1. **인터럽트 기반 I/O 처리 :** I/O 작업 완료 시 장치가 인터럽트를 발생시켜 CPU에 알림
2. **인터럽트 서비스 루틴(ISR) :** 인터럽트 발생 시 커널이 실행하는 I/O 처리 코드
3. **비동기 I/O 지원 :** CPU와 I/O 작업을 병렬적으로 수행 가능
4. **디바이스 드라이버 제공 :** 하드웨어 차이를 추상화하여 일관된 I/O 인터페이스 제공

기능을 제공함으로써, CPU가 I/O 작업을 기다리지 않고 다른 프로세스를 실행할 수 있도록 하며, I/O 시스템을 효율적이고 안정적으로 관리한다.

## 3. 파일 시스템 관리

> 보조 기억 장치(HDD, SSD)는 대용량 데이터를 영구적으로 저장할 수 있지만, 단순한 블록 단위 저장만으로는 데이터를 효율적으로 관리하거나 사용자가 원하는 형태로 접근하기 어렵다. 또한 여러 프로세스가 동시에 파일에 접근할 경우
데이터 손상이나 일관성 문제가 발생할 수 있다.

- 따라서 OS는

1. **파일과 디렉터리 관리 :** 보조 기억 장치의 데이터를 파일 단위로 구성하고, 디렉터리를 통해 계층적 구조로 관리
2. **파일 시스템 제공 :** 디스크 상의 데이터를 조직화하고 저장·검색·삭제를 관리하는 파일 시스템 구조 제공
3. **파일 접근 방식 관리 :** 순차 접근, 직접 접근 등 다양한 파일 접근 방법 지원
4. **파일 보호 및 접근 제어 :** 파일에 대한 읽기·쓰기·실행 권한을 관리하여 무단 접근 방지

기능을 제공함으로써, 보조 기억 장치의 데이터를 체계적으로 관리하고 여러 프로세스가 안전하고 효율적으로 파일에 접근할 수 있도록 한다.
