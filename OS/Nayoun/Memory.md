# **메모리 관리 (Main Memory Management)**

> 메모리는 실행 중인 프로세스가 **명령어와 데이터를 저장하고 접근하는 핵심 자원**
> 

> 운영체제는 이 메모리를 **안전하고 효율적으로 관리한다!**
> 

## **메모리 관리의 배경**

### **프로세스와 메모리의 관계**

- **프로세스**란 실행 중인 프로그램을 의미하며, 반드시 **메인 메모리(Main Memory)** 에 적재되어야 실행 가능하다.

프로그램이 시작되면 → 독자적인 주소 공간이 형성됨. 

프로그램이 실행되려면 물리적인 메모리 어딘가로 올라가야 하고, 이러면 주소가 바뀌게 된다. 

따라서 프로그램이 물리적인 메모리에 어디로 올라갈지 주소로 결정하는 것을 주소 바인딩이라고 한다!

## **주소 개념과 메모리 할당 과정 (Address Binding)**

### 1. Symbolic Address

변수명, 함수명, 라벨 처럼 개발자 편의성을 위한 주소이다.

ex) `sum, x, goto L1` 과 같은 변수명, 함수명, 라벨

### 2. Logical Address (Virtual Address)

각 프로세스가 독립적으로 갖는 CPU 주소이다. → 즉, CPU가 보는 주소!

ex) `346, x01000`처럼 프로세스 기준으로 보는 주소

### 3. Physical Address

메인 메모리(RAM)에 실제로 적재된 위치이다. 

## **Address Binding이란?**

코드가 컴파일 되면 독자적인 숫자 주소가 만들어지고, 실행 되려면 물리적 메모리에 올라가야 하기 때문에 symbolic address → physical address로의 주소 변환이 필요하다. 

그리고 주소가 변환되는 시점에는 크게 3가지가 있다.

### Compile Time Binding

- 컴파일 할 때 이미 물리적 주소가 결정된다.
- 이렇게 미리 결정이 되어야 하기 때문에 Logical Memory 그대로 물리적 메모리 주소로 올려야 한다. → 이러면 굉장히 비효율적! 왜냐? 물리적 메모리에 주소가 많이 비었는데도 불구하고, 항상 0번지부터 Logical Address에 올려야 하기 때문에.

### Load Time Binding

- 컴파일 떄에는 논리적인 주소만 결정이 되고, 메모리에 올라갈 떄 물리적 주소가 결정됨!

### Execution Time Binding (Run Time)

- 프로그램이 시작할 때 주소가 결정되는 부분은 똑같으나, 실행 도중에 물리적 주소가 바뀔 수 있다!
- ⇒ 이게 현재 시스템에 사용되는 방식이다. 하지만 Run Time Binding 방식은 CPU가 메모리 주소를 요청할 떄마다 Binding을 체크해 주소 변환을 그때그때 해줘야 하므로 하드웨어 (MMU)가 필요하다!

## **MMU (Memory Management Unit)**

> 논리적 주소 → 물리적 주소 변환을 담당하는 **하드웨어 장치**
> 

### **MMU의 역할**

- CPU가 생성한 **논리 주소**를 **물리 주소로 변환**하여 메모리에 접근하도록 한다.

### **MMU의 구성 요소**

<img width="715" height="492" alt="image" src="https://github.com/user-attachments/assets/4642b7f7-af88-4111-82c6-bc2379e8e7a3" />


- **Relocation Register =** MMU에서의 Base Register (=메모리에 프로그램이 할당될 때 프로그램의 시작 register 주소) !
    - 논리 주소 + 재배치 값 = 물리 주소

For example, 논리 주소가 346, 재배치 레지스터가 14000이면 물리 주소 **14346이다!**

## **동적 로딩 (Dynamic Loading)**

**로딩** : 메모리에 데이터를 옮기는 것. 

프로그램 전체를 **한 번에 메모리에 올릴 필요는 없다! 따라서, 동적 로딩을 사용해 필**요한 **루틴(함수)** 만 메모리에 적재해서, 실제 호출 시점에 로딩하도록 하면 더 효율적이게 된다. 

⇒ 하지만 이거는 메모리가 부족했을 때 사용되는 방법이였고, 가상 메모리가 나오고 나서는 더 필요한 경우가 없어짐!

# 연속 메모리 할당

> 서로 다른 프로세스에 연속적인 메모리 공간을 할당하는 방식.

각각의 프로세스는 다음 프로세스를 포함하는 영역까지의 연속적인 메모리의 단일 영역을 포함하고 있다.

## 메모리 할당

> 메모리 내에 빈 공간이 여러 개 있다면, 프로세스를 어디에 배치해야 하나?

### First Fit

OS가 메모리 내의 빈 공간을 순서대로 검색하다가 → 적재할 수 있는 공간을 발견하면 그 공간에 프로세스를 배치한다!

프로세스가 적재될 수 있는 공간을 발견하는 즉시 메모리를 할당 → 검색 최소화 & 빠른 할당 가능

### Best Fit

OS가 빈 공간을 모두 검색해 본 후 , 적재될 수 있는 공간 중 가장 작은 공간에 프로세스를 배치한다.

### Worst Fit

OS가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 큰 공간에 프로세스를 배치한다.

<img width="729" height="75" alt="image" src="https://github.com/user-attachments/assets/7b476d3b-7fd2-4ca7-aa45-d942d02e4729" />

위와 같은 메모리 공간이 있다고 가정할때 200MB, 15MB, 185MB, 75MB, 175MB, 80MB가 순서대로 요청할때 **First-Fit, Best-Fit, Worst-Fit**으로 할당한 결과는 다음과 같다. 

<img width="729" height="148" alt="image" src="https://github.com/user-attachments/assets/4b7282ec-81a3-4603-a38b-2094e589f977" />


## 외부 단편화

> 연속 메모리의 할당의 문제점
> 

→ 연속 메모리 할당을 하면, 프로세스를 할당하기 어려울 만큼 작은 메모리 공간들로 인해 메모리가 낭비된다!

<img width="652" height="428" alt="image" src="https://github.com/user-attachments/assets/2f355a3a-9931-41d8-9191-2f37dfaa89c6" />

즉, 위와 같은 사용자 영역에서(프로세스가 적재된 공간), 총 비어있는 메모리 공간은 100MB이나, 프로세스 C를 담을 만큼 연속적인 공간이 생기지 않아, 할당할 수 없고, 결론적으로 남아있는 메모리 공간이 낭비되게 된다!

**그러면 이게 왜 문제가 되냐?**

연속 메모리 할당 환경에서는, 프로세스들이 실행되고 종료되는 과정이 반복되며 메모리 사이사이에 빈 공간들이 생긴다. 이런식으로 빈 공간들이 계속 생기면 → 그 공간보다 큰 프로세스를 적재하기 어려운 상황이 초래된다. 

**그러면 해결 방법은?**

**Compaction!** → 여기저기 흩어져 있는 빈 공간들을 하나로 모은다. 

하지만 이 방식에는 다음과 같은 문제점이 있다.

1. 압축하는 동안 시스템은 하던 일을 모두 중지해야 한다.
2. 메모리에 있던 내용을 옮기는 일은 많은 오버헤드를 야기한다.
3. 어떤 프로세스를 어떻게 움직여야 오버헤드를 최소화하며 압축할 수 있는지 명확한 방법이 없다.

**그러면 또 다른 해결 방법은? → 페이징!**

## 내부 단편화

페이징에서, 프로세스가 페이지 단위로 쪼개지지 않아, 남은 프로세스가 낭비되는 현상

<img width="329" height="338" alt="image" src="https://github.com/user-attachments/assets/a493f4fc-5911-4132-a60e-eba3ce1f9c2d" />


따라서 OS는 내부 단편화를 적당히 방지하며, 너무 크지 않은 페이지 테이블이 만들어지지 않도록 하는 페이지 크기를 자동으로 계산한다.

## 스와핑

> **Prob :** 메모리에 적재된 프로세스 중에는 현재 실행되지 않는 프로세스가 있을 수 있다. (ex) 대기 상태 or 오랫동안 사용되지 않은 프로세스)
> 

**Sol :** 따라서 이런 프로세스를 임시 **보조기억장치**로 쫓아내고, 그렇게 해서 **생긴 메모리상의 빈 공간에 또 다른 프로세스를 적재**하여 실행하는 방식으로 해결한다!

<img width="691" height="497" alt="image" src="https://github.com/user-attachments/assets/9879708f-615b-40bc-9049-7cc109be8821" />


**Swap Space** : 오른쪽에, 프로세스들이 쫓겨나는 보조기억장치의 일부 영역

**Swap Out** : 현재 실행되지 않은 프로세스가 메모리에서 swap 영역 (=backing store)로 옮겨지는 것

**Swap In** : Swap 영역에 있던 프로세스가 다시 메모리로 옮겨져 오는 것. 

**Swap Out** 되었던 프로세스가 다시 **Swap In** 되었을 때는 전의 물리 주소와는 다른 주소에 적재될 수 있다!

이러한 스와핑을 이용하면, 프로세스들이 요구하는 메모리 주소 공간의 크기가 실제 메모리 크기보다 큰 경우에도 프로세스들을 동시에 실행할 수 있다!

<aside>
💡 우리 컴퓨터의 스왑 크기는 `free -h`을 통해서 확인할 수 있다.

</aside>

# Paging

메모리에 페이지를 연속적으로 할당하면 → 메모리보다 큰 프로그램을 적재할 수 없다.

따라서 **Virtual Memory**라는 기술을 사용해, 실행하고자 하는 프로그램 일부만 메모리에 적재해, 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 한다.

가상 메모리 기법에는 **Paging, Segmentation**이 있지만, 오늘날 **대부분의 OS는 페이징을 사용**한다.

> **프로세스의 논리 주소 공간을 Page라는 일정한 단위**로 자르고, **메모리 물리 주소 공간을 Frame**이라는 크기로 자른뒤, 페이지를 프레임에 할당하는 관리 기법
> 

페이징에도 **SwapOut / SwapIn 개념이 사용**된다! 

즉, 메모리에 적재될 필요가 필요없는 페이지는 보조기억장치로 Page Out 되고, 필요한 페이지들은 Page In이 된다. 

## Page Table

하지만, 프로세스가 메모리에 불연속적으로 배치되어 있다면 
→ **CPU는 프로세스를 이루는 페이지가 어느 프레임에 적재되어 있는지 알기 어렵기 때문**에 
→ **실행하기 어려워 진다.**

<img width="717" height="500" alt="image" src="https://github.com/user-attachments/assets/29cf91b1-f62c-48c9-9556-378e27601a73" />


이를 해결하기 위해, **물리 주소 (실제 메모리 내 주소)에 불연속적으로 배치**되더라도, 
**논리 주소 (CPU가 바라보는 주소)에는 연속적으로 배치**되도록 페이지 테이블을 사용한다!

즉, CPU는 페이지 테이블을 통해 페이지 번호만 보고 해당 페이지가 어떤 프레임에 할당되었는지 알려준다.

### PTBR : Page Table Base Register

각 프로세스의 페이지 테이블이 적재된 주소를 가리킨다.

<img width="612" height="237" alt="image" src="https://github.com/user-attachments/assets/082bcf06-0704-47fb-83f8-2ef8ab24d0f6" />


**Prob :** 그런데 이런 구조를 사용하면, 메모리 접근 시간이 두 배로 늘어난다

→ 페이지 테이블 접근, 그리고 프레임 접근하기 위해.

### Sol : TLB : Translation Lookaside Buffer

CPU 옆에 두어지는 캐시 메모리.

캐시이기 때문에, 페이지 테이블의 일부 내용을 저장할 수 있고, 참조 지역성에 근거해 주로 최근에 사용된 페이지를 위주로 가져와 저장한다.

<img width="622" height="459" alt="image" src="https://github.com/user-attachments/assets/81ca60d8-2b1c-43a3-8642-b3358ebdb8cc" />


**TLB Hit :** CPU가 발생한 논리 주소에 대한 페이지 번호가 TLB에 있다.

**TLB Miss :** TLB에 없어서 메모리 내의 페이지 테이블을 접근할 때 !

## 페이징에서의 주소 변환

메모리의 특정 주소에 접근하려면 다음과 같은 정보가 필요하다.

1. 어떤 `page` or `frame`?
2. 접근하려는 주소가 page or frame으로부터 얼마나 떨어져 있는지?

때문에 **페이징 시스템에서는 모든 논리 주소가 `page number & offset` 으로 이루어져 있다!**

CPU가 32bit address를 내보냈다면, 그 중 `N비트`는 `page number`, `32-N 비트`는 `offset`.

`page number` → 접근하고자 하는 페이지 번호 (페이지가 어떤 프레임에 할당되었는지?)

`offset` → 접근하려는 주소가 frame의 시작 번지로부터 얼만큼 떨어져있는지?

즉, `<Page #, offset> → <Frame #, offset>` 으로 변환된다.

## PTE : Page Table Entry

<img width="714" height="262" alt="image" src="https://github.com/user-attachments/assets/a48da695-f9af-40fc-b5e2-eee4db45b0e4" />


- `Valid bit`
    - **현재 해당 페이지에 접근 가능한지 여부 알려줌**
    - 메모리에 적재되어 있지 않다면 0,  적재되어 있다면 1
    - 현재 페이지가 메모리에 적재돼 있는지 여부 알려주는 비트이므로 페이지가 메모리 내에 없다면 아래와 같은 `Exception`(=`Page Fault`)이 발생한다!
- `Protection Bit`
    - **페이지에 접근할 권한을 제한하여 페이지를 보호하는 기능을 제공**해준다.
    - 해당 페이지가 읽기/쓰기 모두 가능한 페이지인지, 읽기만 가능한 페이지인지 나타냄
    - 읽기만: `0`/ 읽기와 쓰기: `1`
    - 읽기 `r(Read)`/ 쓰기 `w(Write)`/ 실행 `x(eXecute)`
        - ex) 보호 비트 `100: r 1/ w 0/ x 0` => 읽기만 가능
- `Reference Bit`
    - **CPU가 이 페이지에 접근한 적 있는지 여부** 알려줌
    - 적재 이후 한 번도 읽거나 쓴 적 없었다면, 페이지는 0으로 유지,  CPU가 읽거나 쓴 페이지면 1
- `Modified bit` = `Dirty bit`
    - **해당 페이지에 데이터를 쓴 적 있는지 없는지 수정 여부** 알려줌
    - 한번도 접근한 적 없거나, 읽기만 했던 페이지면 0, 변경된 적 있는 페이지면 1
    - 그럼 왜 존재할까?
        - → **페이지가 메모리에서 사라질 때 보조기억장치에 쓰기 작업을 해야 하는지, 할 필요 없는지 판단**해준다!
    - 읽기만 한 페이지면 CPU는 다음과 같이 판단한다.
        - 보조기억장치에 저장된 해당 페이지의 내용 == 메모리에 저장된 페이지의 내용
            - => 한 번도 수정된 적 X 페이지가 스왑 아웃 -> 새로 적재된 페이지로 덮어쓰면 됨
    - 하지만, 쓰기 작업한 페이지면, CPU는 다음과 같이 판단한다.
        - 보조기억장치에 저장된 해당 페이지의 내용 != 메모리에 저장된 페이지의 내용
        - => 변경된 값을 보조기억장치에 기록하는 작업 추가

# 페이지 교체 알고리즘

<aside>
💡 가상 메모리를 통해 물리 메모리보다 큰 프로세스를 실행할 수 있지만, 그럼에도 불구하고 물리 메모리의 크기는 한정되어 있다.

따라서 **OS는 프로세스들이 한정된 메모리를 효율적으로 이**용할 수 있도록,

1. **메모리에 적재된 불필요한 페이지를 선별하여 보조기억장치로 내보낼 수** 있어야 하고
2. **프로세스들에 적절한 수의 프레임을 할당해 페이지를 할당**할 수 있게 해야 한다.

</aside>

## Demand Paging

> 프로세스를 메모리에 적재할때, **필요한 페이지만을 메모리에 적재**하는 기법
이를 수행하기 위해서는 **1. 페이지 교체 , 2. 프레임 할당** 문제를 반드시 해결해야 한다.
> 

### 절차

1. CPU가 특정 페이지에 접근하는 명령어 실행
2. `Valid Bit == 1` (=해당 페이지가 현재 메모리에 있으면), CPU는 페이지가 적재된 프레임에 접근
3. `Valid Bit == 0`, `Page Fault` 발생
    1. `Page Fault Routine` 실행 → 해당 페이지를 메모리로 적재하고, `Valid Bit = 1`로 설정
    2. 다시 1번 수행
<aside>
- `pure demand paging`이란?
    - 아무런 페이지도 메모리에 적재되지 않으면 → Page Fault가 계속 발생 → 어느 정도 시점부터 Page Fault 발생 빈도가 떨어짐
</aside>

## Page Replacement Algorithm

> `demand paging`으로 페이지를 적재하다 보면 → 언젠가 메모리가 가득차게 된다. 
그러면 메모리에 적재된 페이지를 보조기억장치로 내보내야 되는데, **내보내는 페이지를 결정하는 기법 = 페이지 교체 알고리즘**이라 한다!
> 

일반적으로 `Page Fault`를 가장 적게 일으키는 알고리즘을 가장 좋은 알고리즘으로 평가한다.

왜냐? → `Page Fault`가 많이 발생하면 = 보조기억장치로 내쫓을 페이지를 잘못 골랐다 = 컴퓨터의 성능을 저해하기 때문!

<aside>
💡 Page Reference String?

CPU가 참조하는 페이지들 중 연속된 페이지를 생략한 페이지열

`2 2 2 3 5 5 5 3 3 7` → `2 3 5 3 7`

</aside>

우리는 다음과 예제를 사용해서 알고리즘을 공부해도록 한다.

<aside>

<img width="631" height="181" alt="image" src="https://github.com/user-attachments/assets/7996e44c-d4a6-4186-a497-e2c51925b2bd" />


Reference String : `7 0 1 2 0 3 0 4 2 3 0 3 0 3 2 1 2 0 1 7 0 1`
메모리의 프레임 개수 : 3개

즉, 7 0 1 중에 어떤 것을 내쫓을 것인가?

</aside>

### First-in First-out

<aside>
💡 메모리에 가장 먼저 올라온 페이지부터 내쫓음.

</aside>

<img width="723" height="193" alt="image" src="https://github.com/user-attachments/assets/50794a4f-eb1a-47dd-ae9a-3775717fda2c" />


이 알고리즘은 15 번의 `Page Fault`을 발생시켰다. 

아이디어와 구현은 간단하지만, 프로그램 실행 초기에 적재된 페이지 중 실행 내내 사용될 내용을 포함하고 있는 페이지를 내쫓을 수 있으므로, 효율이 안좋을 수 있다.

### Optimal Page Replacement Algorithm

<aside>
💡 CPU에 의해 참조되는 횟수를 고려하는 페이지 교체 알고리즘

즉, 앞으로 긴 주기동안 사용하지 않을 것 같은 페이지를 교체한다. 

</aside>

즉, 사용 빈도가 가장 낮 페이지를 교체한다.

<img width="707" height="197" alt="image" src="https://github.com/user-attachments/assets/a270b1fd-3957-4500-a9dd-58493f232ce2" />


4번째 과정에서 2번 페이지를 넣고자 할 때, 7번 페이지가 가장 안 쓰이기 때문에, 7번 페이지와 교체한다.

이 알고리즘은 9 번의 `Page Fault`을 발생시킨다.

하지만 앞으로 오랫동안 사용되지 않을 페이지 예측이 어려우므로, 성능 평가 목적으로만 사용된다.

### Least Recently Used Page Replacement Algorithm

<aside>
💡 **가장 오랫동안 사용되지 않은** 페이지 교체하는 알고리즘

</aside>

<img width="719" height="199" alt="image" src="https://github.com/user-attachments/assets/b0b901eb-5b3e-426e-a413-1aa9b3374bfc" />


- 4번째 과정에서 2번 페이지를 넣고자 할때 7번 페이지가 가장 오랫동안 사용되지 않았으므로 7번 페이지를 페이지 아웃시키고 2번 페이지를 넣는다.
- 6번째 과정에서 3번 페이지를 넣고자 할때 1번 페이지가 가장 오랫동안 사용되지 않았으므로 1번 페이지와 교환한다.
- 페이지 폴트 발생 횟수 : `12회`

## Thrashing

<aside>
💡 효율적인 페이지 교체 알고리즘을 선택했다고 해서, 프로세스에 사용할 수 있는 프레임 수가 적어지면, `Page Fault`가 자주 발생한다.

</aside>

왜냐? → 프레임이 무한히 많은 컴퓨터와 프레임이 한 개만 있는 컴퓨터를 비교해보면, 전자는 페이지를 수용할 공간이 넉넉해 모든 프로세스의 페이지가 메모리에 적재될 수 있지만, 후자는 새로운 페이지를 참조할 때 마다 Page Fault가 발생한다.

이렇게, **프로세스가 실제 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능이 저해되는 문제** = `Thrashing`이라고 한다!

<img width="672" height="389" alt="image" src="https://github.com/user-attachments/assets/743246fe-cd68-4e13-8283-81b757b009af" />


`x축` : 메모리에 올라와 동시에 실행 중인 프로세스 개수. 

`y축` : CPU가 실제로 일을 하고 있는 비율

프로세스 수가 증가하면 CPU 이용률이 점차 증가하는 양상을 보이지만, `thrashing` 구간에서는 프로세스가 너무 많아져, 각 프로세스가 필요한 페이지를 메모리에 유지하지 못하는 문제가 발생해 CPU 이용률이 급락하게 된다. 

Thrashing이 발생하는 원인은, **각 프로세스가 필요로 하는 최소한의 프레임 수가 보장**되지 않았기 때문이다. 
따라서 OS는** 각 프로세스들이 무리 없이 실행하기 위한 최소한의 프레임 수를 파악**하고 **프로세스들에 적절한 수만큼 프레임을 할당**해 줄 수 있어야 한다. 

**프레임의 할당 방식 - 1. 정적 할당 방식**

단순히 프로세스의 물리 메모리 크기만 고려한다!

1. `Equal Allocation`
    1. 모든 프로세스들에게 동등하게 프레임들을 똑같이 할당함
2. `Proportional Allocation`
    1. 프로세스의 크기에 따라서 프레임을 차등 할당함

**프레임의 할당 방식 - 1. 동적 할당 방식**

프로세스를 실행해보고, 할당할 프레임 수를 결정한다.

1. `Working Set Model`
    1. Working Set 크기 만큼한 프레임을 할당한다.
    2. 즉, 프로세스가 일정 기간 동안 참조한 페이지 집합을 기억해, 빈번한 페이지 교체를 방지한다
2. `Page-Fault Frequency`
    1. Page Fault 율에 상한선과 하한선을 정하고, 그 내부 범위 안에서만 프레임을 할당한다.
