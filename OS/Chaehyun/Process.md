## 프로세스 구조와 최적화

### 프로세스

- 실행 중인 프로그램
    - 프로그램 카운터의 값과 처리기 레지스터의 내용으로 대표되는 현재 활동을 포함
    - 실행 파일이 메모리에 load될 때 프로그램은 프로세스가 됨

| 프로그램 | 프로세스 |
| --- | --- |
| 어떤 작업을 하기 위해 실행할 수 있는 파일 | 실행되어 작업 중인 컴퓨터 프로그램 |
| 파일이 저장 장치에 있지만 메모리에는 올라가 있지 않은 정적인 상태 | 메모리에 적재되고 CPU 자원을 할당받아 프로그램이 실행되고 있는 상태 |
| 코드 덩어리 | 코드 덩어리를 실행한 것 |

### 프로세스와 스레드

- 프로세스의 한계
    - 프로세스 작업 하나만을 사용해서 프로그램을 실행하기에는 한계
    - 동일한 프로그램을 여러 개의 프로세스로 만들면, 그만큼 메모리를 차지하고 CPU에 할당받는 자원이 중복될 것
    
    ⇒ 스레드의 탄생
    
- 스레드의 개념
    - 하나의 프로세스 내에서 동시에 진행되는 작업 갈래, 흐름의 단위
    - 여러가지 작업들 흐름이 동시에 진행 ⇒ 일련의 작업 흐름들을 스레드라고 함
    - 하나의 프로세스는 반드시 하나 이상의 스레드를 가짐
- 스레드의 자원 공유
    - 스레드끼리 프로세스의 자원을 공유하면서 프로세스 실행 흐름의 일부가 되기 때문에 동시 작업이 가능
    - 독립적인 스택 → 독립적인 함수 호출 → 독립적인 실행흐름이 추가
        
        ⇒ 스택을 가짐으로써 스레드는 독립적인 실행 흐름을 가질 수 있음
        
- 프로세스의 자원 공유
    - IPC
    - LPC
    - 별도로 공유 메모리
    - RAM과 CPU 사이의 캐시 메모리까지 초기화됨
        
        → 자원 부담
        
        ⇒ 다중 작업이 필요한 경우 스레드를 이용하는 것이 훨씬 효율적
        

### 프로세스 메모리 구조

<img width="888" height="988" alt="image" src="https://github.com/user-attachments/assets/97edb004-8fa4-41e9-ab45-e0d5b5e293c0" />


- Code(Text) 영역
    - 소스코드 저장
    - 프로그램 실행 도중 코드가 변경되면 안되므로 Read-Only 상태
- Data 영역
    - 전역변수와 정적변수가 저장
    - 프로그램이 시작될 때 할당되고, 종료될때까지 유지
- Heap 영역
    - 프로그래머가 필요할때 동적으로 할당하는 영역
    - 런타입에 크기가 결정
    - 메모리의 낮은 주소에서 높은 주소 방향으로 채워짐
    - 관리가 안되면 메모리 누수가 발생하는 주원인
- Stack 영역
    - 함수 호출시 생성되는 지역 변수, 매개변수, 리턴 주소 저장
    - 함수가 종료되면 자동으로 제거
    - 메모리의 높은 주소에서 낮은 주소 방향으로 채워짐
    - LIFO 구조라 접근 속도 빠름
- Stack vs Heap
    - heap은 위로, stack은 아래로 할당
    - 두 영역이 만나 공간이 부족ㅎ지면 Stack Overflow 또는 HeapOverflow 발생
    - 스택에 있는 변수(포인터/참조값)가 힙에 있는 실제 거대 데이터 객체를 가리키는 방식으로 동작
    - 스택은 스레드마다 독립적, 힙은 모든 스레드가 공유 → 동기화 문제 발생 가능

### 컨텍스트 스위칭(Context Switching)

- CPU가 한 프로세스에서 다른 프로세스로 실행을 옮기는 과정
- 운영체제는 실행 중이던 프로세스의 상태(Context)를 어딘가에 저장해두고, 새로 실행할 프로세스의 상태를 불러옴
    - PCB(Process Control Block): 상태 정보를 저장하는 곳(PC(Program Counter), 레지스터 값 저장)
- 저장하고 불러오는게 왜 그렇게 시스템 성능에 안좋은가?
    
    ⇒ 단순히 데이터를 쓰고 읽는 시간 때문만은 아님
    
    - 만약 CPU 캐시 메모리 입장에서 생각해보면, 프로세스 A에서 B로 바뀔 때 캐시에 저장되어 있던 A의 데이터들은 어떻게 될까?
- 컨텍스트 스위칭의 두가지 비용
    1. 직접 비용 (Direct Overhead)
        - 눈에 보이는, CPU가 실제로 수행해야 하는 작업들
        - 레지스터 교체: 현재 실행 중인 프로세스의 레지스터 값(PC, SP 등)을 PCB(Process Control Block)에 저장하고, 다음 프로세스의 값을 로드함
        - 커널 모드 전환: 유저 모드에서 커널 모드로의 전환 비용(like System Call)이 발생
        - 스케줄러 실행: “누구를 다음 타자로 보낼까?”를 결정하는 스케줄러 코드 자체가 실행되는 시간
    2. 간접 비용 (Indirect Overhead)
        - 캐시 오염 (Cache Pollution)
            - CPU 캐시(L1, L2, L3)는 현재 실행 중인 프로세스 A의 데이터가 Hot 상태
            - 프로세스가 B로 바뀌는 순간, 캐시에 있던 A의 데이터는 Garbage가 됨
            - 프로세스 B가 실행되면서 필요한 데이터를 다시 메인 메모리(RAM)에서 가져와야 하므로, 초기 실행 속도가 급격히 느려짐 ⇒ Cold Cache
        - TLB(Translation Lookaside Buffer) 플러시
            - 가상 메모리 주소를 물리 주소로 변환해주는 캐시인 TLB도 비워야 할 수 있음
                - 프로세스마다 주소 공간이 다르기 때문
            - 메모리 접근 성능이 일시적으로 저하됨
        - 스레드 간의 컨텍스트 스위칭이 프로세스보다 빠른 이유: 스레드는 같은 메모리 공간(Code, Data, Heap)을 공유하므로, 스위칭 시 캐시나 TLB를 비울 필요가 적기 떄문
- 개발자는 무엇을 할 수 있나?
    - Processor Affinity (프로세서 친화성)
        - 특정 프롯세스를 가능한 한 이전에 실행했던 CPU 코어에서 다시 실행되도록 스케줄링 하는 기법
        - 코어의 캐시에 아직 해당 프로세스의 데이터가 남아있을 확률이 높기 때문
        - Cache Warmth 유지

+) 함수가 호출되면 일어나는일

<img width="684" height="558" alt="image" src="https://github.com/user-attachments/assets/f05e32a8-73d2-43ac-9af5-5c94fa3e1884" />


1. function parameters를 push, pc의 값을 stack에 return address로 push
2. 그 위치의 stack pointer는 callee가 caller 위치로 돌아가기 위해 return address가 위치한 곳이므로 여기의 주소를 frame pointer에 저장
3. frame pointer는 함수가 return 할 때의 위치를 저장해놓은 stack의 위치
4. stack pointer는 local varaible까지 저장하고 그 바로 위를 가리킴
5. stack frame은 parameter부터 local variable까지 callee에게 할당된 stack의 메모리 공간 의미

## 프로세스 states

- 생성: 프로세스가 막 생성되었지만, 아직 운영체제에 의해 실행가능하도록 승인받지 못한 상태
- 준비: 모든 준비를 마치고 CPU를 할당받기 위해 줄을 서서 기다리는 상태
- 실행: 드디어 CPU를 차지하여 명령어를 실제로 처리하고 있는 상태
- 대기: 프로세스 입출력 완료나 특정 이벤트를 기다려야 해서, 스스로 CPU를 반납하고 멈춰있는 상태
- 종료: 실행이 완료되었거나 강제로 중단되어 프로세스가 사라지는 상태

### 상태 전이도

<img width="1538" height="840" alt="image" src="https://github.com/user-attachments/assets/654beed3-294d-4f8d-82f6-74235b357bb5" />


1. fork()를 사용하면 프로그램이 new 상태의 프로세스가 됨
2. new에서 cpu를 제외한 모든 자원이 준비된 것이 확인되면 ready상태가 되고 Ready queue로 들어감
3. cpu-scheduling에 의해서 cpu 할당을 받으면 running 상태가 됨. Ready queue에 있던 ready 상태의 프로세스를 running 상태로 scheduler가 dispatch함
    - scheduler dispatcher: 프로세스가 전환될 때 PCB를 해당 프로세스의 PCB로 전환 시켜주고 register, pc, mmu등의 내용을 바뀐 프로세스로 전환 시켜 주는 os내의 프로그램
4. I/O 사용이 필요한 경우 running상태에서 waiting로 상태가 전환되고 I/O 사용이 끝나면 다시 ready상태가 되어 queue에 들어감
5. exit()하거나 main 함수 return, kill 명령어 사용시 프로세스가 terminated됨

## PCB(Process Control Block)

- 운영체제에서 프로세스를 관리하기 위해 해당 프로세스의 상태 정보를 담고 있는 자료구조
- 프로세스를 컨텍스트 스위칭 할때 기존 프로세스의 상태를 어딘가에 저장해 둬야 다음에 똑같은 작업 이어서 가능
- 새로 해야 할 작업의 상태 알아야 작업 시작할지 결정 가능
- 프로세스 스케줄링을 위해 프로세스에 관한 모든 정보 저장하는 임시 저장소

## 동기화의 경쟁 상태 (Synchronization & Race Condition)

### 경쟁 상태

```c
int count = 0; // 공유 자원 (Data 영역 또는 Heap 영역)

// Thread A 와 Thread B가 동시에 이 코드를 실행
count++;
```

- 기대: A한번, B한번 더해서 결과가 2
    
    but, 실제 컴퓨터 구조상(기계어 레벨), 두 스레드가 타이밍이 꼬여서 동시에 실행되면 결과가 1일 될 수 있음
    
    1. LOAD (읽기): 메모리에 있는 count 값을 CPU 레지스터로 가져옴
    2. ADD (수정): 레지스터에 있는 값에 1을 더함 (현재 레지스터 값: 1)
    3. STORE(쓰기): 1이 된 레지스터 값을 다시 메모리 count 주소에 저장
    
    ⇒ 스레드 A가 1번과 2번을 수행해서 레지스터 값을 1로 만듦 
    → 3번을 하기 직전에 운영체제가 스레드 A를 멈추고 스레드 B로 실행을 넘기면(컨텍스트 스위칭) 
    → 스레드 B가 메모리에 있는 count값을 읽으면 0을 읽어서 1을 더하고 1을 메모리에 저장 
    → 다시 스레드 A는 아까 레지스터에 1을 들고 있던 상태로 복귀 
    → 저장하면 스레드 A도 메모리에 1을 덮어씀
    
- 여러 스레드가 동시에 접근해서 실행 결과가 접근 순서에 따라 달라지는 현상을 경쟁 상태라고 함
- 임계 구역: `count++` 처럼 공유 자원에 접근하는 코드 영역 ⇒ 여러 스레드가 동시에 들어가서 난장판이 되는 걸 막는 것이 동기화의 핵심 목표
    - Mutex(상호배제): 락을 걸어 한번에 하나의 스레드만 접근을 허용하는 기술 (동기화 대상이 하나)
    - Semaphore(세마포어): 공유된 자원의 데이터 혹은 임계구역 등에 여러 프로세스 혹은 스레드가 접근하는 것을 막음 (동기화 대상이 하나 이상)
    - 만약 자리가 없다면
        1. Block: 스레드가 대기 큐로 보내짐
        2. Sleep: 누군가 자리를 비워줄 때까지 CPU를 쓰지 않음
        3. Wake up: 나중에 스레드가 나오면서 signal()을 보내면, 입장
- OS 스레드: 전통적인 방식에서 스레드를 재우고 깨우는 관리를 운영체제 커널이 직접 담당
    - 대용량 트래픽을 처리하느라 스레드를 10만개 만듦 → 대부분이 DB 응답을 기다리느라 Block되어있다면
    - 10만개의 무거운 스레드를 관리하고 문맥 교한하는 비용은 저렴할까?
        - 엄청나게 비쌈
        - 스레드 하나가 생성될 때 약 1MB 정도의 스택 메모리를 미리 잡음
            - 10만개면 스레드 생성만으로 100GB이 필요
            - 많은 스레드를 꼈다 뺐다(Context Switching)하면 CPU는 일을 못하고 관리만 하게 됨
- 사용자 수준 스레드
    - Green Thread, Coroutine, Goroutine, Virtual Thread
    - OS 스레드 1개가 수천 개의 가상 스레드를 번갈아 가며 실행(M:N 모델)
